package main

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/http/httputil"
	"net/url"
	"os"
	"os/signal"
	"plugin"
	"runtime"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/gorilla/mux"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"gopkg.in/yaml.v3"
	"golang.org/x/time/rate"
)

// Config represents the gateway configuration
type Config struct {
	Server struct {
		Port             int           `yaml:"port"`
		ReadTimeout      time.Duration `yaml:"readTimeout"`
		WriteTimeout     time.Duration `yaml:"writeTimeout"`
		IdleTimeout      time.Duration `yaml:"idleTimeout"`
		PluginsDir       string        `yaml:"pluginsDir"`
		EnableLogging    bool          `yaml:"enableLogging"`
		TLSCertFile      string        `yaml:"tlsCertFile"`
		TLSKeyFile       string        `yaml:"tlsKeyFile"`
		ClientCACertFile string        `yaml:"clientCACertFile"` // For mTLS
		MetricsPort      int           `yaml:"metricsPort"`
	} `yaml:"server"`

	Security struct {
		EnableMTLS             bool          `yaml:"enableMTLS"`
		EnableCSRF             bool          `yaml:"enableCSRF"`
		CSRFTokenExpiry        time.Duration `yaml:"csrfTokenExpiry"`
		RateLimitRequests      int           `yaml:"rateLimitRequests"`
		RateLimitInterval      time.Duration `yaml:"rateLimitInterval"`
		EnableXSS              bool          `yaml:"enableXSS"`
		EnableHSTS             bool          `yaml:"enableHSTS"`
		HSTSMaxAge             int           `yaml:"hstsMaxAge"`
		EnableSecureCookies    bool          `yaml:"enableSecureCookies"`
		JWTSecret              string        `yaml:"jwtSecret"`
		JWTIssuer              string        `yaml:"jwtIssuer"`
		EnableIPWhitelisting   bool          `yaml:"enableIPWhitelisting"`
		WhitelistedIPs         []string      `yaml:"whitelistedIPs"`
		EnableRequestValidation bool         `yaml:"enableRequestValidation"`
		MaxRequestBodySize     int64         `yaml:"maxRequestBodySize"`
	} `yaml:"security"`

	Routes []struct {
		Path           string            `yaml:"path"`
		Destination    string            `yaml:"destination"`
		Methods        []string          `yaml:"methods"`
		RequireAuth    bool              `yaml:"requireAuth"`
		RateLimit      *int              `yaml:"rateLimit"`
		Timeout        *time.Duration    `yaml:"timeout"`
		Headers        map[string]string `yaml:"headers"`
		StripPath      bool              `yaml:"stripPath"`
		ValidateSchema string            `yaml:"validateSchema"`
	} `yaml:"routes"`

	Plugins []struct {
		Name    string                 `yaml:"name"`
		Path    string                 `yaml:"path"`
		Enabled bool                   `yaml:"enabled"`
		Config  map[string]interface{} `yaml:"config"`
	} `yaml:"plugins"`
}

// GatewayPlugin interface that all plugins must implement
type GatewayPlugin interface {
	Name() string
	Initialize(config map[string]interface{}) error
	Middleware() func(http.Handler) http.Handler
	Shutdown() error
}

// Gateway is the main API gateway struct
type Gateway struct {
	config      *Config
	router      *mux.Router
	plugins     []GatewayPlugin
	pluginsMu   sync.RWMutex
	middlewares []func(http.Handler) http.Handler
	rateLimiter *RateLimiter
	metrics     *Metrics
	logger      *Logger
}

// Logger provides structured logging for the gateway
type Logger struct {
	enableLogging bool
}

// NewLogger creates a new logger instance
func NewLogger(enableLogging bool) *Logger {
	return &Logger{
		enableLogging: enableLogging,
	}
}

// Info logs informational messages
func (l *Logger) Info(format string, v ...interface{}) {
	if l.enableLogging {
		log.Printf("[INFO] "+format, v...)
	}
}

// Error logs error messages
func (l *Logger) Error(format string, v ...interface{}) {
	if l.enableLogging {
		log.Printf("[ERROR] "+format, v...)
	}
}

// Warn logs warning messages
func (l *Logger) Warn(format string, v ...interface{}) {
	if l.enableLogging {
		log.Printf("[WARN] "+format, v...)
	}
}

// Metrics collects and exposes gateway metrics
type Metrics struct {
	requestCount    *prometheus.CounterVec
	requestDuration *prometheus.HistogramVec
	responseSize    *prometheus.HistogramVec
	activeRequests  *prometheus.GaugeVec
}

// NewMetrics creates a new metrics instance
func NewMetrics() *Metrics {
	m := &Metrics{
		requestCount: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Name: "gateway_requests_total",
				Help: "Total number of requests processed by the gateway",
			},
			[]string{"method", "path", "status"},
		),
		requestDuration: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name: "gateway_request_duration_seconds",
				Help: "Duration of requests processed by the gateway",
			},
			[]string{"method", "path"},
		),
		responseSize: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name: "gateway_response_size_bytes",
				Help: "Size of responses returned by the gateway",
			},
			[]string{"method", "path"},
		),
		activeRequests: prometheus.NewGaugeVec(
			prometheus.GaugeOpts{
				Name: "gateway_active_requests",
				Help: "Number of active requests being processed by the gateway",
			},
			[]string{"method"},
		),
	}

	// Register all metrics
	prometheus.MustRegister(m.requestCount)
	prometheus.MustRegister(m.requestDuration)
	prometheus.MustRegister(m.responseSize)
	prometheus.MustRegister(m.activeRequests)

	return m
}

// RateLimiter manages rate limiting for the gateway
type RateLimiter struct {
	limiters   map[string]*rate.Limiter
	mu         sync.RWMutex
	perRouteLimit map[string]*rate.Limiter
	globalRequests int
	globalInterval time.Duration
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter(requests int, interval time.Duration) *RateLimiter {
	return &RateLimiter{
		limiters:       make(map[string]*rate.Limiter),
		perRouteLimit:  make(map[string]*rate.Limiter),
		globalRequests: requests,
		globalInterval: interval,
	}
}

// GetLimiter returns a rate limiter for a specific IP address
func (rl *RateLimiter) GetLimiter(ip string) *rate.Limiter {
	rl.mu.RLock()
	limiter, exists := rl.limiters[ip]
	rl.mu.RUnlock()

	if !exists {
		limiter = rate.NewLimiter(rate.Every(rl.globalInterval/time.Duration(rl.globalRequests)), rl.globalRequests)
		rl.mu.Lock()
		rl.limiters[ip] = limiter
		rl.mu.Unlock()
	}

	return limiter
}

// RegisterRouteLimit sets a specific rate limit for a route
func (rl *RateLimiter) RegisterRouteLimit(route string, limit int) {
	rl.mu.Lock()
	defer rl.mu.Unlock()
	rl.perRouteLimit[route] = rate.NewLimiter(rate.Every(rl.globalInterval/time.Duration(limit)), limit)
}

// GetRouteLimiter returns a rate limiter for a specific route and IP
func (rl *RateLimiter) GetRouteLimiter(route string, ip string) *rate.Limiter {
	routeKey := route + ":" + ip
	
	rl.mu.RLock()
	limiter, exists := rl.limiters[routeKey]
	routeLimiter, routeExists := rl.perRouteLimit[route]
	rl.mu.RUnlock()

	if !exists {
		if routeExists {
			// Create a new limiter based on the route-specific configuration
			limit := routeLimiter.Limit()
			burst := routeLimiter.Burst()
			limiter = rate.NewLimiter(limit, burst)
		} else {
			// Fall back to the global rate limit
			limiter = rate.NewLimiter(rate.Every(rl.globalInterval/time.Duration(rl.globalRequests)), rl.globalRequests)
		}
		
		rl.mu.Lock()
		rl.limiters[routeKey] = limiter
		rl.mu.Unlock()
	}

	return limiter
}

// IPWhitelist manages whitelisted IP addresses
type IPWhitelist struct {
	enabled     bool
	whitelistedIPs []string
}

// NewIPWhitelist creates a new IP whitelist
func NewIPWhitelist(enabled bool, ips []string) *IPWhitelist {
	return &IPWhitelist{
		enabled:     enabled,
		whitelistedIPs: ips,
	}
}

// IsAllowed checks if an IP is allowed
func (ip *IPWhitelist) IsAllowed(addr string) bool {
	if !ip.enabled {
		return true
	}

	for _, whitelisted := range ip.whitelistedIPs {
		if whitelisted == addr || whitelisted == "*" {
			return true
		}
	}

	return false
}

// NewGateway creates a new API gateway instance
func NewGateway(configPath string) (*Gateway, error) {
	config, err := loadConfig(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load config: %w", err)
	}

	logger := NewLogger(config.Server.EnableLogging)
	metrics := NewMetrics()
	rateLimiter := NewRateLimiter(
		config.Security.RateLimitRequests, 
		config.Security.RateLimitInterval * time.Second,
	)

	// Set up custom rate limits for routes if configured
	for _, route := range config.Routes {
		if route.RateLimit != nil {
			rateLimiter.RegisterRouteLimit(route.Path, *route.RateLimit)
		}
	}

	gateway := &Gateway{
		config:      config,
		router:      mux.NewRouter(),
		plugins:     make([]GatewayPlugin, 0),
		middlewares: make([]func(http.Handler) http.Handler, 0),
		rateLimiter: rateLimiter,
		metrics:     metrics,
		logger:      logger,
	}

	// Set up the router
	gateway.setupRoutes()

	// Load plugins
	if err := gateway.loadPlugins(); err != nil {
		return nil, fmt.Errorf("failed to load plugins: %w", err)
	}

	return gateway, nil
}

// loadConfig loads the gateway configuration from a YAML file
func loadConfig(path string) (*Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var config Config
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, err
	}

	return &config, nil
}

// setupRoutes configures the routes from the config
func (g *Gateway) setupRoutes() {
	// Add health check endpoint
	g.router.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(`{"status":"UP"}`))
	}).Methods(http.MethodGet)

	// Configure routes from the config
	for _, route := range g.config.Routes {
		handler := g.proxyHandler(route)
		
		// Apply route-specific middleware
		if route.RequireAuth {
			handler = g.authMiddleware(handler)
		}
		
		// Apply route-specific timeout if configured
		if route.Timeout != nil {
			handler = g.timeoutMiddleware(*route.Timeout)(handler)
		}
		
		// Apply schema validation if configured
		if route.ValidateSchema != "" {
			handler = g.validateRequestMiddleware(route.ValidateSchema)(handler)
		}

		g.router.HandleFunc(route.Path, handler).
			Methods(route.Methods...)
	}

	// Add catch-all route for 404s
	g.router.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusNotFound)
		w.Write([]byte(`{"error":"Not Found","message":"The requested resource does not exist"}`))
	})
}

// proxyHandler returns a handler function that proxies requests to the destination
func (g *Gateway) proxyHandler(route struct {
	Path           string            `yaml:"path"`
	Destination    string            `yaml:"destination"`
	Methods        []string          `yaml:"methods"`
	RequireAuth    bool              `yaml:"requireAuth"`
	RateLimit      *int              `yaml:"rateLimit"`
	Timeout        *time.Duration    `yaml:"timeout"`
	Headers        map[string]string `yaml:"headers"`
	StripPath      bool              `yaml:"stripPath"`
	ValidateSchema string            `yaml:"validateSchema"`
}) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		
		// Parse the destination URL
		target, err := url.Parse(route.Destination)
		if err != nil {
			g.logger.Error("Failed to parse destination URL: %v", err)
			w.WriteHeader(http.StatusInternalServerError)
			w.Write([]byte(`{"error":"Internal Server Error"}`))
			return
		}

		// Create the reverse proxy
		proxy := httputil.NewSingleHostReverseProxy(target)
		
		// Customize the director function to modify the request
		originalDirector := proxy.Director
		proxy.Director = func(req *http.Request) {
			originalDirector(req)
			
			// Strip the path prefix if configured
			if route.StripPath {
				req.URL.Path = strings.TrimPrefix(req.URL.Path, route.Path)
				if req.URL.Path == "" {
					req.URL.Path = "/"
				}
			}
			
			// Add custom headers
			for key, value := range route.Headers {
				req.Header.Set(key, value)
			}
			
			// Add X-Forwarded headers
			req.Header.Set("X-Forwarded-Host", req.Host)
			req.Header.Set("X-Forwarded-For", getClientIP(req))
			
			// Add X-Request-ID for tracking
			if reqID := r.Header.Get("X-Request-ID"); reqID == "" {
				req.Header.Set("X-Request-ID", generateRequestID())
			} else {
				req.Header.Set("X-Request-ID", reqID)
			}
		}
		
		// Customize the error handler
		proxy.ErrorHandler = func(w http.ResponseWriter, r *http.Request, err error) {
			g.logger.Error("Proxy error: %v", err)
			w.WriteHeader(http.StatusBadGateway)
			w.Write([]byte(`{"error":"Bad Gateway","message":"Unable to reach the upstream service"}`))
		}
		
		// Customize the response writer to log and collect metrics
		lrw := newLoggingResponseWriter(w)
		
		// Execute the proxy
		proxy.ServeHTTP(lrw, r)
		
		// Record metrics
		duration := time.Since(start).Seconds()
		g.metrics.requestDuration.WithLabelValues(r.Method, route.Path).Observe(duration)
		g.metrics.requestCount.WithLabelValues(r.Method, route.Path, fmt.Sprintf("%d", lrw.statusCode)).Inc()
		g.metrics.responseSize.WithLabelValues(r.Method, route.Path).Observe(float64(lrw.bytesWritten))
		
		// Log the request
		g.logger.Info("%s %s %d %s %dB", r.Method, r.URL.Path, lrw.statusCode, time.Since(start), lrw.bytesWritten)
	}
}

// generateRequestID generates a unique request ID
func generateRequestID() string {
	return fmt.Sprintf("%d", time.Now().UnixNano())
}

// getClientIP gets the client IP address from the request
func getClientIP(r *http.Request) string {
	// Check for X-Forwarded-For header
	forwardedFor := r.Header.Get("X-Forwarded-For")
	if forwardedFor != "" {
		// X-Forwarded-For can contain multiple IPs, take the first one
		ips := strings.Split(forwardedFor, ",")
		return strings.TrimSpace(ips[0])
	}
	
	// Check for X-Real-IP header
	realIP := r.Header.Get("X-Real-IP")
	if realIP != "" {
		return realIP
	}
	
	// Fall back to RemoteAddr
	return strings.Split(r.RemoteAddr, ":")[0]
}

// loadPlugins loads and initializes all enabled plugins
func (g *Gateway) loadPlugins() error {
	for _, pluginConfig := range g.config.Plugins {
		if !pluginConfig.Enabled {
			g.logger.Info("Plugin %s is disabled, skipping", pluginConfig.Name)
			continue
		}

		g.logger.Info("Loading plugin: %s from %s", pluginConfig.Name, pluginConfig.Path)

		// Load the plugin
		plug, err := plugin.Open(pluginConfig.Path)
		if err != nil {
			return fmt.Errorf("failed to open plugin %s: %w", pluginConfig.Name, err)
		}

		// Look up the plugin's constructor
		symPlugin, err := plug.Lookup("Plugin")
		if err != nil {
			return fmt.Errorf("failed to lookup 'Plugin' symbol in %s: %w", pluginConfig.Name, err)
		}

		// Cast to the GatewayPlugin interface
		gatewayPlugin, ok := symPlugin.(GatewayPlugin)
		if !ok {
			return fmt.Errorf("plugin %s does not implement GatewayPlugin interface", pluginConfig.Name)
		}

		// Initialize the plugin with its configuration
		if err := gatewayPlugin.Initialize(pluginConfig.Config); err != nil {
			return fmt.Errorf("failed to initialize plugin %s: %w", pluginConfig.Name, err)
		}

		// Add the plugin to the list
		g.pluginsMu.Lock()
		g.plugins = append(g.plugins, gatewayPlugin)

		// Register the plugin's middleware
		middleware := gatewayPlugin.Middleware()
		if middleware != nil {
			g.middlewares = append(g.middlewares, middleware)
		}
		g.pluginsMu.Unlock()

		g.logger.Info("Plugin %s loaded successfully", pluginConfig.Name)
	}

	return nil
}

// Serve starts the gateway server
func (g *Gateway) Serve() error {
	// Apply core security middlewares first
	var handler http.Handler = g.router
	
	// Apply security middlewares
	handler = g.rateLimitMiddleware(handler)
	handler = g.ipWhitelistMiddleware(handler)
	handler = g.securityHeadersMiddleware(handler)
	handler = g.csrfMiddleware(handler)
	handler = g.requestSizeMiddleware(handler)
	
	// Apply plugin middlewares in reverse order (last added, first executed)
	for i := len(g.middlewares) - 1; i >= 0; i-- {
		handler = g.middlewares[i](handler)
	}

	// Add logging middleware if enabled
	if g.config.Server.EnableLogging {
		handler = g.loggingMiddleware(handler)
	}

	// Add metrics middleware
	handler = g.metricsMiddleware(handler)

// Add recovery middleware
	handler = g.recoveryMiddleware(handler)

	// Configure the server
	addr := fmt.Sprintf(":%d", g.config.Server.Port)
	server := &http.Server{
		Addr:         addr,
		Handler:      handler,
		ReadTimeout:  g.config.Server.ReadTimeout * time.Second,
		WriteTimeout: g.config.Server.WriteTimeout * time.Second,
		IdleTimeout:  g.config.Server.IdleTimeout * time.Second,
	}

	// Configure TLS if cert and key files are provided
	var tlsConfig *tls.Config
	if g.config.Server.TLSCertFile != "" && g.config.Server.TLSKeyFile != "" {
		tlsConfig = &tls.Config{
			MinVersion: tls.VersionTLS12,
			CipherSuites: []uint16{
				tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
				tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
				tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,
				tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
				tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
				tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
			},
			PreferServerCipherSuites: true,
		}
		
		// Configure mTLS if enabled and client CA cert is provided
		if g.config.Security.EnableMTLS && g.config.Server.ClientCACertFile != "" {
			caCert, err := os.ReadFile(g.config.Server.ClientCACertFile)
			if err != nil {
				return fmt.Errorf("failed to read client CA cert file: %w", err)
			}
			
			caCertPool := x509.NewCertPool()
			if !caCertPool.AppendCertsFromPEM(caCert) {
				return fmt.Errorf("failed to parse client CA cert file")
			}
			
			tlsConfig.ClientCAs = caCertPool
			tlsConfig.ClientAuth = tls.RequireAndVerifyClientCert
		}
		
		server.TLSConfig = tlsConfig
	}

	// Start metrics server on a separate port
	if g.config.Server.MetricsPort > 0 {
		metricsServer := &http.Server{
			Addr:    fmt.Sprintf(":%d", g.config.Server.MetricsPort),
			Handler: promhttp.Handler(),
		}
		
		go func() {
			g.logger.Info("Starting metrics server on :%d", g.config.Server.MetricsPort)
			if err := metricsServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
				g.logger.Error("Failed to start metrics server: %v", err)
			}
		}()
	}

	// Handle graceful shutdown
	done := make(chan os.Signal, 1)
	signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		g.logger.Info("Starting gateway server on %s", addr)
		var err error
		if server.TLSConfig != nil {
			err = server.ListenAndServeTLS(g.config.Server.TLSCertFile, g.config.Server.TLSKeyFile)
		} else {
			err = server.ListenAndServe()
		}
		
		if err != nil && err != http.ErrServerClosed {
			g.logger.Error("Failed to start server: %v", err)
			os.Exit(1)
		}
	}()

	<-done
	g.logger.Info("Server is shutting down...")

	// Shutdown plugins
	g.shutdownPlugins()

	// Create a deadline to wait for
	ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	defer cancel()

	if err := server.Shutdown(ctx); err != nil {
		return fmt.Errorf("server forced to shutdown: %w", err)
	}

	g.logger.Info("Server gracefully stopped")
	return nil
}

// shutdownPlugins gracefully shuts down all plugins
func (g *Gateway) shutdownPlugins() {
	g.pluginsMu.RLock()
	defer g.pluginsMu.RUnlock()

	for _, p := range g.plugins {
		if err := p.Shutdown(); err != nil {
			g.logger.Error("Error shutting down plugin %s: %v", p.Name(), err)
		} else {
			g.logger.Info("Plugin %s shutdown successfully", p.Name())
		}
	}
}

// Security Middlewares

// rateLimitMiddleware implements rate limiting
func (g *Gateway) rateLimitMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Get client IP
		clientIP := getClientIP(r)
		
		// Get route-specific limiter if available
		limiter := g.rateLimiter.GetRouteLimiter(r.URL.Path, clientIP)
		
		// Check if the request is allowed
		if !limiter.Allow() {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusTooManyRequests)
			w.Write([]byte(`{"error":"Too Many Requests","message":"Rate limit exceeded"}`))
			return
		}
		
		next.ServeHTTP(w, r)
	})
}

// timeoutMiddleware sets a timeout for the request handling
func (g *Gateway) timeoutMiddleware(timeout time.Duration) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			ctx, cancel := context.WithTimeout(r.Context(), timeout*time.Second)
			defer cancel()
			
			r = r.WithContext(ctx)
			
			done := make(chan bool)
			go func() {
				next.ServeHTTP(w, r)
				done <- true
			}()
			
			select {
			case <-done:
				return
			case <-ctx.Done():
				if ctx.Err() == context.DeadlineExceeded {
					w.Header().Set("Content-Type", "application/json")
					w.WriteHeader(http.StatusGatewayTimeout)
					w.Write([]byte(`{"error":"Gateway Timeout","message":"Request processing timed out"}`))
				}
				return
			}
		})
	}
}

// metricsMiddleware collects metrics for requests
func (g *Gateway) metricsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		
		// Track active requests
		g.metrics.activeRequests.WithLabelValues(r.Method).Inc()
		
		// Use custom response writer to capture status code and size
		lrw := newLoggingResponseWriter(w)
		
		next.ServeHTTP(lrw, r)
		
		// Track metrics
		duration := time.Since(start).Seconds()
		path := r.URL.Path
		
		g.metrics.requestDuration.WithLabelValues(r.Method, path).Observe(duration)
		g.metrics.requestCount.WithLabelValues(r.Method, path, fmt.Sprintf("%d", lrw.statusCode)).Inc()
		g.metrics.responseSize.WithLabelValues(r.Method, path).Observe(float64(lrw.bytesWritten))
		
		// Decrease active requests counter
		g.metrics.activeRequests.WithLabelValues(r.Method).Dec()
	})
}

// recoveryMiddleware recovers from panics
func (g *Gateway) recoveryMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer func() {
			if err := recover(); err != nil {
				// Log the error
				g.logger.Error("Panic recovered: %v", err)
				
				// Return an error to the client
				w.Header().Set("Content-Type", "application/json")
				w.WriteHeader(http.StatusInternalServerError)
				w.Write([]byte(`{"error":"Internal Server Error","message":"An unexpected error occurred"}`))
			}
		}()
		
		next.ServeHTTP(w, r)
	})
}

// validateRequestMiddleware validates request payloads against a schema
func (g *Gateway) validateRequestMiddleware(schemaPath string) func(http.Handler) http.Handler {
	// In a real implementation, this would load and validate against a JSON Schema
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Skip validation for GET and HEAD requests
			if r.Method == http.MethodGet || r.Method == http.MethodHead {
				next.ServeHTTP(w, r)
				return
			}
			
			// Read the request body
			body, err := io.ReadAll(r.Body)
			if err != nil {
				w.Header().Set("Content-Type", "application/json")
				w.WriteHeader(http.StatusBadRequest)
				w.Write([]byte(`{"error":"Bad Request","message":"Failed to read request body"}`))
				return
			}
			
			// Restore the request body for downstream handlers
			r.Body = io.NopCloser(strings.NewReader(string(body)))
			
			// Check if the body is valid JSON
			var jsonData interface{}
			if err := json.Unmarshal(body, &jsonData); err != nil {
				w.Header().Set("Content-Type", "application/json")
				w.WriteHeader(http.StatusBadRequest)
				w.Write([]byte(`{"error":"Bad Request","message":"Invalid JSON payload"}`))
				return
			}
			
			// In a real implementation, this would validate against the schema
			// For this example, we'll just check that the body is not empty
			if len(body) == 0 {
				w.Header().Set("Content-Type", "application/json")
				w.WriteHeader(http.StatusBadRequest)
				w.Write([]byte(`{"error":"Bad Request","message":"Empty request body"}`))
				return
			}
			
			next.ServeHTTP(w, r)
		})
	}
}
	})
}

// ipWhitelistMiddleware implements IP whitelisting
func (g *Gateway) ipWhitelistMiddleware(next http.Handler) http.Handler {
	whitelist := NewIPWhitelist(g.config.Security.EnableIPWhitelisting, g.config.Security.WhitelistedIPs)
	
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		clientIP := getClientIP(r)
		
		if !whitelist.IsAllowed(clientIP) {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusForbidden)
			w.Write([]byte(`{"error":"Forbidden","message":"IP address not allowed"}`))
			return
		}
		
		next.ServeHTTP(w, r)
	})
}

// securityHeadersMiddleware adds security headers to responses
func (g *Gateway) securityHeadersMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Set security headers
		w.Header().Set("X-Content-Type-Options", "nosniff")
		w.Header().Set("X-Frame-Options", "DENY")
		
		// Set XSS Protection header if enabled
		if g.config.Security.EnableXSS {
			w.Header().Set("X-XSS-Protection", "1; mode=block")
		}
		
		// Set HSTS header if enabled
		if g.config.Security.EnableHSTS {
			maxAge := g.config.Security.HSTSMaxAge
			if maxAge <= 0 {
				maxAge = 31536000 // Default to 1 year
			}
			w.Header().Set("Strict-Transport-Security", fmt.Sprintf("max-age=%d; includeSubDomains", maxAge))
		}
		
		next.ServeHTTP(w, r)
	})
}

// csrfMiddleware implements CSRF protection
func (g *Gateway) csrfMiddleware(next http.Handler) http.Handler {
	if !g.config.Security.EnableCSRF {
		return next
	}
	
	// In a real implementation, this would use a proper CSRF token implementation
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Only check CSRF for state-changing methods
		if r.Method == http.MethodPost || r.Method == http.MethodPut || 
		   r.Method == http.MethodDelete || r.Method == http.MethodPatch {
			// Check CSRF token
			token := r.Header.Get("X-CSRF-Token")
			if token == "" {
				w.Header().Set("Content-Type", "application/json")
				w.WriteHeader(http.StatusForbidden)
				w.Write([]byte(`{"error":"Forbidden","message":"CSRF token missing"}`))
				return
			}
			
			// Validate token (simplified for example purposes)
			// In a real implementation, this would validate the token against a stored value
			if len(token) < 32 {
				w.Header().Set("Content-Type", "application/json")
				w.WriteHeader(http.StatusForbidden)
				w.Write([]byte(`{"error":"Forbidden","message":"Invalid CSRF token"}`))
				return
			}
		}
		
		next.ServeHTTP(w, r)
	})
}

// requestSizeMiddleware limits the size of incoming requests
func (g *Gateway) requestSizeMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Skip for GET and HEAD requests
		if r.Method == http.MethodGet || r.Method == http.MethodHead {
			next.ServeHTTP(w, r)
			return
		}
		
		// Check Content-Length header
		if r.ContentLength > g.config.Security.MaxRequestBodySize {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusRequestEntityTooLarge)
			w.Write([]byte(`{"error":"Request Entity Too Large","message":"Request body too large"}`))
			return
		}
		
		// Limit the request body
		r.Body = http.MaxBytesReader(w, r.Body, g.config.Security.MaxRequestBodySize)
		
		next.ServeHTTP(w, r)
	})
}

// authMiddleware implements JWT authentication
func (g *Gateway) authMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Extract the token from the Authorization header
		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusUnauthorized)
			w.Write([]byte(`{"error":"Unauthorized","message":"Missing authorization header"}`))
			return
		}
		
		// Check that it's a Bearer token
		parts := strings.Split(authHeader, " ")
		if len(parts) != 2 || parts[0] != "Bearer" {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusUnauthorized)
			w.Write([]byte(`{"error":"Unauthorized","message":"Invalid authorization format"}`))
			return
		}
		
		tokenString := parts[1]
		
		// In a real implementation, this would validate the JWT token
		// For this example, we'll just check that the token is not empty
		if tokenString == "" {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusUnauthorized)
			w.Write([]byte(`{"error":"Unauthorized","message":"Invalid token"}`))
			return
		}
		
		// Add claims to the request context for downstream handlers
		// In a real implementation, this would parse and validate the JWT token
		// and add the claims to the request context
		
		next.ServeHTTP(w, r)
	})
}

// loggingMiddleware logs all requests
func (g *Gateway) loggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		
		// Log the request
		g.logger.Info("Request: %s %s %s", r.Method, r.URL.Path, r.RemoteAddr)
		
		// Use custom response writer to capture status code
		lrw := newLoggingResponseWriter(w)
		
		next.ServeHTTP(lrw, r)
		
		// Log the response
		g.logger.Info("Response: %s %s %d %s", r.Method, r.URL.Path, lrw.statusCode, time.Since(start))
	})
}

// loggingResponseWriter is a custom response writer that captures the status code
type loggingResponseWriter struct {
	http.ResponseWriter
	statusCode   int
	bytesWritten int64
}

// newLoggingResponseWriter creates a new logging response writer
func newLoggingResponseWriter(w http.ResponseWriter) *loggingResponseWriter {
	return &loggingResponseWriter{
		ResponseWriter: w,
		statusCode:     http.StatusOK, // Default status code
	}
}

// WriteHeader captures the status code
func (lrw *loggingResponseWriter) WriteHeader(code int) {
	lrw.statusCode = code
	lrw.ResponseWriter.WriteHeader(code)
}

// Write captures the number of bytes written
func (lrw *loggingResponseWriter) Write(b []byte) (int, error) {
	n, err := lrw.ResponseWriter.Write(b)
	lrw.bytesWritten += int64(n)
	return n, err
}

// main is the entry point for the gateway
func main() {
	// Parse command line flags
	configPath := flag.String("config", "config.yaml", "Path to the configuration file")
	flag.Parse()

	// Create the gateway
	gateway, err := NewGateway(*configPath)
	if err != nil {
		log.Fatalf("Failed to create gateway: %v", err)
	}

	// Start the gateway
	if err := gateway.Serve(); err != nil {
		log.Fatalf("Gateway server failed: %v", err)
	}
}

// Plugin development helpers

// PluginConfig represents a plugin configuration
type PluginConfig struct {
	Name    string
	Version string
	Author  string
}

// BasePlugin provides a base implementation of the GatewayPlugin interface
type BasePlugin struct {
	config PluginConfig
	logger *log.Logger
}

// NewBasePlugin creates a new base plugin
func NewBasePlugin(config PluginConfig) *BasePlugin {
	return &BasePlugin{
		config: config,
		logger: log.New(os.Stdout, fmt.Sprintf("[%s] ", config.Name), log.LstdFlags),
	}
}

// Name returns the plugin name
func (p *BasePlugin) Name() string {
	return p.config.Name
}

// Initialize initializes the plugin
func (p *BasePlugin) Initialize(config map[string]interface{}) error {
	p.logger.Printf("Initializing plugin %s v%s by %s", p.config.Name, p.config.Version, p.config.Author)
	return nil
}

// Middleware returns the plugin middleware
func (p *BasePlugin) Middleware() func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			next.ServeHTTP(w, r)
		})
	}
}

// Shutdown shuts down the plugin
func (p *BasePlugin) Shutdown() error {
	p.logger.Printf("Shutting down plugin %s", p.config.Name)
	return nil
}

// Example plugin implementations

// LoggingPlugin logs requests and responses
type LoggingPlugin struct {
	*BasePlugin
	logFile *os.File
}

// NewLoggingPlugin creates a new logging plugin
func NewLoggingPlugin() *LoggingPlugin {
	return &LoggingPlugin{
		BasePlugin: NewBasePlugin(PluginConfig{
			Name:    "logging",
			Version: "1.0.0",
			Author:  "Gateway Team",
		}),
	}
}

// Initialize initializes the logging plugin
func (p *LoggingPlugin) Initialize(config map[string]interface{}) error {
	if err := p.BasePlugin.Initialize(config); err != nil {
		return err
	}
	
	// Get the log file path from the config
	logFilePath, ok := config["logFile"].(string)
	if !ok {
		logFilePath = "gateway.log" // Default log file
	}
	
	// Open the log file
	var err error
	p.logFile, err = os.OpenFile(logFilePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		return fmt.Errorf("failed to open log file: %w", err)
	}
	
	// Set the logger output to the log file
	p.logger.SetOutput(p.logFile)
	
	return nil
}

// Middleware returns the logging middleware
func (p *LoggingPlugin) Middleware() func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			start := time.Now()
			
			// Log the request
			p.logger.Printf("Request: %s %s %s", r.Method, r.URL.Path, r.RemoteAddr)
			
			// Use custom response writer to capture status code
			lrw := newLoggingResponseWriter(w)
			
			next.ServeHTTP(lrw, r)
			
			// Log the response
			p.logger.Printf("Response: %s %s %d %s %d bytes", r.Method, r.URL.Path, lrw.statusCode, time.Since(start), lrw.bytesWritten)
		})
	}
}

// Shutdown shuts down the logging plugin
func (p *LoggingPlugin) Shutdown() error {
	if err := p.BasePlugin.Shutdown(); err != nil {
		return err
	}
	
	// Close the log file
	if p.logFile != nil {
		if err := p.logFile.Close(); err != nil {
			return fmt.Errorf("failed to close log file: %w", err)
		}
	}
	
	return nil
}

// CachePlugin implements response caching
type CachePlugin struct {
	*BasePlugin
	cache     map[string]cacheEntry
	cacheMu   sync.RWMutex
	ttl       time.Duration
	maxItems  int
	whitelist []string
}

// cacheEntry represents a cached response
type cacheEntry struct {
	response []byte
	headers  http.Header
	status   int
	expiry   time.Time
}

// NewCachePlugin creates a new cache plugin
func NewCachePlugin() *CachePlugin {
	return &CachePlugin{
		BasePlugin: NewBasePlugin(PluginConfig{
			Name:    "cache",
			Version: "1.0.0",
			Author:  "Gateway Team",
		}),
		cache: make(map[string]cacheEntry),
	}
}

// Initialize initializes the cache plugin
func (p *CachePlugin) Initialize(config map[string]interface{}) error {
	if err := p.BasePlugin.Initialize(config); err != nil {
		return err
	}
	
	// Get the TTL from the config
	ttl, ok := config["ttl"].(float64)
	if !ok {
		ttl = 60 // Default TTL in seconds
	}
	p.ttl = time.Duration(ttl) * time.Second
	
	// Get the max items from the config
	maxItems, ok := config["maxItems"].(float64)
	if !ok {
		maxItems = 1000 // Default max items
	}
	p.maxItems = int(maxItems)
	
	// Get the whitelist from the config
	whitelist, ok := config["whitelist"].([]interface{})
	if ok {
		p.whitelist = make([]string, len(whitelist))
		for i, path := range whitelist {
			if pathStr, ok := path.(string); ok {
				p.whitelist[i] = pathStr
			}
		}
	}
	
	// Start the cache cleaner
	go p.cleanCache()
	
	return nil
}

// Middleware returns the cache middleware
func (p *CachePlugin) Middleware() func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Only cache GET requests
			if r.Method != http.MethodGet {
				next.ServeHTTP(w, r)
				return
			}
			
			// Check if the path is in the whitelist
			if !p.isWhitelisted(r.URL.Path) {
				next.ServeHTTP(w, r)
				return
			}
			
			// Generate cache key
			key := r.URL.String()
			
			// Check if the response is cached
			p.cacheMu.RLock()
			entry, found := p.cache[key]
			p.cacheMu.RUnlock()
			
			if found && time.Now().Before(entry.expiry) {
				// Serve from cache
				for k, v := range entry.headers {
					w.Header()[k] = v
				}
				w.WriteHeader(entry.status)
				w.Write(entry.response)
				p.logger.Printf("Cache hit: %s", key)
				return
			}
			
			// Cache miss, capture the response
			crw := newCachingResponseWriter(w)
			next.ServeHTTP(crw, r)
			
			// Only cache successful responses
			if crw.statusCode >= 200 && crw.statusCode < 300 {
				p.cacheMu.Lock()
				
				// Check cache size and evict if necessary
				if len(p.cache) >= p.maxItems {
					p.evictOldest()
				}
				
				// Store in cache
				p.cache[key] = cacheEntry{
					response: crw.body.Bytes(),
					headers:  crw.Header().Clone(),
					status:   crw.statusCode,
					expiry:   time.Now().Add(p.ttl),
				}
				p.cacheMu.Unlock()
				
				p.logger.Printf("Cache miss: %s", key)
			}
		})
	}
}

// isWhitelisted checks if a path is in the whitelist
func (p *CachePlugin) isWhitelisted(path string) bool {
	// If no whitelist is specified, cache everything
	if len(p.whitelist) == 0 {
		return true
	}
	
	for _, prefix := range p.whitelist {
		if strings.HasPrefix(path, prefix) {
			return true
		}
	}
	
	return false
}

// evictOldest evicts the oldest cache entry
func (p *CachePlugin) evictOldest() {
	var oldestKey string
	var oldestTime time.Time
	
	// Set initial oldest time to future
	oldestTime = time.Now().Add(24 * time.Hour)
	
	// Find the oldest entry
	for key, entry := range p.cache {
		if entry.expiry.Before(oldestTime) {
			oldestKey = key
			oldestTime = entry.expiry
		}
	}
	
	// Delete the oldest entry
	if oldestKey != "" {
		delete(p.cache, oldestKey)
		p.logger.Printf("Cache eviction: %s", oldestKey)
	}
}

// cleanCache periodically cleans expired entries
func (p *CachePlugin) cleanCache() {
	ticker := time.NewTicker(time.Minute)
	defer ticker.Stop()
	
	for range ticker.C {
		p.cacheMu.Lock()
		
		// Remove expired entries
		now := time.Now()
		for key, entry := range p.cache {
			if now.After(entry.expiry) {
				delete(p.cache, key)
				p.logger.Printf("Cache expiry: %s", key)
			}
		}
		
		p.cacheMu.Unlock()
	}
}

// Shutdown shuts down the cache plugin
func (p *CachePlugin) Shutdown() error {
	if err := p.BasePlugin.Shutdown(); err != nil {
		return err
	}
	
	// Clear the cache
	p.cacheMu.Lock()
	p.cache = make(map[string]cacheEntry)
	p.cacheMu.Unlock()
	
	return nil
}

// cachingResponseWriter is a custom response writer that captures the response
type cachingResponseWriter struct {
	*loggingResponseWriter
	body *strings.Builder
}

// newCachingResponseWriter creates a new caching response writer
func newCachingResponseWriter(w http.ResponseWriter) *cachingResponseWriter {
	return &cachingResponseWriter{
		loggingResponseWriter: newLoggingResponseWriter(w),
		body:                 &strings.Builder{},
	}
}

// Write captures the response body
func (crw *cachingResponseWriter) Write(b []byte) (int, error) {
	// Write to the original response writer
	n, err := crw.loggingResponseWriter.Write(b)
	if err != nil {
		return n, err
	}
	
	// Also write to our buffer
	crw.body.Write(b)
	
	return n, nil
}

// Plugin exports for loading by the gateway

// Plugin is the exported symbol for the logging plugin
var Plugin = NewLoggingPlugin()