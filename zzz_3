package main

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/http/httputil"
	"net/url"
	"os"
	"os/signal"
	"plugin"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/gorilla/mux"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"golang.org/x/time/rate"
	"gopkg.in/yaml.v3"
)

// Define Prometheus metrics
var (
	httpRequestsTotal = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "http_requests_total",
			Help: "Total number of HTTP requests",
		},
		[]string{"code", "method", "path"},
	)

	httpRequestDuration = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "http_request_duration_seconds",
			Help:    "HTTP request duration in seconds",
			Buckets: prometheus.DefBuckets,
		},
		[]string{"code", "method", "path"},
	)

	httpResponseSize = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "http_response_size_bytes",
			Help:    "Size of HTTP responses in bytes",
			Buckets: []float64{100, 1000, 10000, 100000, 1000000},
		},
		[]string{"code", "method", "path"},
	)

	activeConnections = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "http_active_connections",
			Help: "Number of active HTTP connections",
		},
	)
)

func init() {
	// Register the metrics with Prometheus
	prometheus.MustRegister(httpRequestsTotal)
	prometheus.MustRegister(httpRequestDuration)
	prometheus.MustRegister(httpResponseSize)
	prometheus.MustRegister(activeConnections)
}

// Config represents the gateway configuration
type Config struct {
	Server struct {
		Port             int           `yaml:"port"`
		ReadTimeout      time.Duration `yaml:"readTimeout"`
		WriteTimeout     time.Duration `yaml:"writeTimeout"`
		IdleTimeout      time.Duration `yaml:"idleTimeout"`
		PluginsDir       string        `yaml:"pluginsDir"`
		EnableLogging    bool          `yaml:"enableLogging"`
		TLSCertFile      string        `yaml:"tlsCertFile"`
		TLSKeyFile       string        `yaml:"tlsKeyFile"`
		ClientCACertFile string        `yaml:"clientCACertFile"` // For mTLS
		MetricsPort      int           `yaml:"metricsPort"`
	} `yaml:"server"`

	Security struct {
		EnableMTLS              bool          `yaml:"enableMTLS"`
		EnableCSRF              bool          `yaml:"enableCSRF"`
		CSRFTokenExpiry         time.Duration `yaml:"csrfTokenExpiry"`
		RateLimitRequests       int           `yaml:"rateLimitRequests"`
		RateLimitInterval       time.Duration `yaml:"rateLimitInterval"`
		EnableXSS               bool          `yaml:"enableXSS"`
		EnableHSTS              bool          `yaml:"enableHSTS"`
		HSTSMaxAge              int           `yaml:"hstsMaxAge"`
		EnableSecureCookies     bool          `yaml:"enableSecureCookies"`
		JWTSecret               string        `yaml:"jwtSecret"`
		JWTIssuer               string        `yaml:"jwtIssuer"`
		EnableIPWhitelisting    bool          `yaml:"enableIPWhitelisting"`
		WhitelistedIPs          []string      `yaml:"whitelistedIPs"`
		EnableRequestValidation bool          `yaml:"enableRequestValidation"`
		MaxRequestBodySize      int64         `yaml:"maxRequestBodySize"`
	} `yaml:"security"`

	Routes []struct {
		Path           string            `yaml:"path"`
		Destination    string            `yaml:"destination"`
		Methods        []string          `yaml:"methods"`
		RequireAuth    bool              `yaml:"requireAuth"`
		RateLimit      *int              `yaml:"rateLimit"`
		Timeout        *time.Duration    `yaml:"timeout"`
		Headers        map[string]string `yaml:"headers"`
		StripPath      bool              `yaml:"stripPath"`
		ValidateSchema string            `yaml:"validateSchema"`
	} `yaml:"routes"`

	Plugins []struct {
		Name    string                 `yaml:"name"`
		Path    string                 `yaml:"path"`
		Enabled bool                   `yaml:"enabled"`
		Config  map[string]interface{} `yaml:"config"`
	} `yaml:"plugins"`
}

// GatewayPlugin interface that all plugins must implement
type GatewayPlugin interface {
	Name() string
	Initialize(config map[string]interface{}) error
	Middleware() func(http.Handler) http.Handler
	Shutdown() error
}

// Gateway is the main API gateway struct
type Gateway struct {
	config      *Config
	router      *mux.Router
	plugins     []GatewayPlugin
	pluginsMu   sync.RWMutex
	middlewares []func(http.Handler) http.Handler
	rateLimiter *RateLimiter
	metrics     *Metrics
	logger      *Logger
}

// Logger provides structured logging for the gateway
type Logger struct {
	enableLogging bool
}

// NewLogger creates a new logger instance
func NewLogger(enableLogging bool) *Logger {
	return &Logger{
		enableLogging: enableLogging,
	}
}

// Info logs informational messages
func (l *Logger) Info(format string, v ...interface{}) {
	if l.enableLogging {
		log.Printf("[INFO] "+format, v...)
	}
}

// Error logs error messages
func (l *Logger) Error(format string, v ...interface{}) {
	if l.enableLogging {
		log.Printf("[ERROR] "+format, v...)
	}
}

// Warn logs warning messages
func (l *Logger) Warn(format string, v ...interface{}) {
	if l.enableLogging {
		log.Printf("[WARN] "+format, v...)
	}
}

// Metrics collects and exposes gateway metrics
type Metrics struct {
	requestCount    *prometheus.CounterVec
	requestDuration *prometheus.HistogramVec
	responseSize    *prometheus.HistogramVec
	activeRequests  *prometheus.GaugeVec
}

// NewMetrics creates a new metrics instance
func NewMetrics() *Metrics {
	m := &Metrics{
		requestCount: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Name: "gateway_requests_total",
				Help: "Total number of requests processed by the gateway",
			},
			[]string{"method", "path", "status"},
		),
		requestDuration: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name: "gateway_request_duration_seconds",
				Help: "Duration of requests processed by the gateway",
			},
			[]string{"method", "path"},
		),
		responseSize: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name: "gateway_response_size_bytes",
				Help: "Size of responses returned by the gateway",
			},
			[]string{"method", "path"},
		),
		activeRequests: prometheus.NewGaugeVec(
			prometheus.GaugeOpts{
				Name: "gateway_active_requests",
				Help: "Number of active requests being processed by the gateway",
			},
			[]string{"method"},
		),
	}

	// Register all metrics
	prometheus.MustRegister(m.requestCount)
	prometheus.MustRegister(m.requestDuration)
	prometheus.MustRegister(m.responseSize)
	prometheus.MustRegister(m.activeRequests)

	return m
}

// RateLimiter manages rate limiting for the gateway
type RateLimiter struct {
	limiters       map[string]*rate.Limiter
	mu             sync.RWMutex
	perRouteLimit  map[string]*rate.Limiter
	globalRequests int
	globalInterval time.Duration
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter(requests int, interval time.Duration) *RateLimiter {
	return &RateLimiter{
		limiters:       make(map[string]*rate.Limiter),
		perRouteLimit:  make(map[string]*rate.Limiter),
		globalRequests: requests,
		globalInterval: interval,
	}
}

// GetLimiter returns a rate limiter for a specific IP address
func (rl *RateLimiter) GetLimiter(ip string) *rate.Limiter {
	rl.mu.RLock()
	limiter, exists := rl.limiters[ip]
	rl.mu.RUnlock()

	if !exists {
		limiter = rate.NewLimiter(rate.Every(rl.globalInterval/time.Duration(rl.globalRequests)), rl.globalRequests)
		rl.mu.Lock()
		rl.limiters[ip] = limiter
		rl.mu.Unlock()
	}

	return limiter
}

// RegisterRouteLimit sets a specific rate limit for a route
func (rl *RateLimiter) RegisterRouteLimit(route string, limit int) {
	rl.mu.Lock()
	defer rl.mu.Unlock()
	rl.perRouteLimit[route] = rate.NewLimiter(rate.Every(rl.globalInterval/time.Duration(limit)), limit)
}

// GetRouteLimiter returns a rate limiter for a specific route and IP
func (rl *RateLimiter) GetRouteLimiter(route string, ip string) *rate.Limiter {
	routeKey := route + ":" + ip

	rl.mu.RLock()
	limiter, exists := rl.limiters[routeKey]
	routeLimiter, routeExists := rl.perRouteLimit[route]
	rl.mu.RUnlock()

	if !exists {
		if routeExists {
			// Create a new limiter based on the route-specific configuration
			limit := routeLimiter.Limit()
			burst := routeLimiter.Burst()
			limiter = rate.NewLimiter(limit, burst)
		} else {
			// Fall back to the global rate limit
			limiter = rate.NewLimiter(rate.Every(rl.globalInterval/time.Duration(rl.globalRequests)), rl.globalRequests)
		}

		rl.mu.Lock()
		rl.limiters[routeKey] = limiter
		rl.mu.Unlock()
	}

	return limiter
}

// IPWhitelist manages whitelisted IP addresses
type IPWhitelist struct {
	enabled        bool
	whitelistedIPs []string
}

// NewIPWhitelist creates a new IP whitelist
func NewIPWhitelist(enabled bool, ips []string) *IPWhitelist {
	return &IPWhitelist{
		enabled:        enabled,
		whitelistedIPs: ips,
	}
}

// IsAllowed checks if an IP is allowed
func (ip *IPWhitelist) IsAllowed(addr string) bool {
	if !ip.enabled {
		return true
	}

	for _, whitelisted := range ip.whitelistedIPs {
		if whitelisted == addr || whitelisted == "*" {
			return true
		}
	}

	return false
}

// NewGateway creates a new API gateway instance
func NewGateway(configPath string) (*Gateway, error) {
	config, err := loadConfig(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load config: %w", err)
	}

	logger := NewLogger(config.Server.EnableLogging)
	metrics := NewMetrics()
	rateLimiter := NewRateLimiter(
		config.Security.RateLimitRequests,
		config.Security.RateLimitInterval*time.Second,
	)

	// Set up custom rate limits for routes if configured
	for _, route := range config.Routes {
		if route.RateLimit != nil {
			rateLimiter.RegisterRouteLimit(route.Path, *route.RateLimit)
		}
	}

	gateway := &Gateway{
		config:      config,
		router:      mux.NewRouter(),
		plugins:     make([]GatewayPlugin, 0),
		middlewares: make([]func(http.Handler) http.Handler, 0),
		rateLimiter: rateLimiter,
		metrics:     metrics,
		logger:      logger,
	}

	// Set up the router
	gateway.setupRoutes()

	// Load plugins
	if err := gateway.loadPlugins(); err != nil {
		return nil, fmt.Errorf("failed to load plugins: %w", err)
	}

	return gateway, nil
}

// loadConfig loads the gateway configuration from a YAML file
func loadConfig(path string) (*Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var config Config
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, err
	}

	return &config, nil
}

// setupRoutes configures the routes from the config
func (g *Gateway) setupRoutes() {
	// Add health check endpoint
	g.router.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(`{"status":"UP"}`))
	}).Methods(http.MethodGet)

	// Configure routes from the config
	for _, route := range g.config.Routes {
		handler := g.proxyHandler(route)

		// Apply route-specific middleware
		if route.RequireAuth {
			handler = g.authMiddleware(handler)
		}

		// Apply route-specific timeout if configured
		if route.Timeout != nil {
			handler = g.timeoutMiddleware(*route.Timeout)(handler)
		}

		// Apply schema validation if configured
		if route.ValidateSchema != "" {
			handler = g.validateRequestMiddleware(route.ValidateSchema)(handler)
		}

		g.router.HandleFunc(route.Path, handler).
			Methods(route.Methods...)
	}

	// Add catch-all route for 404s
	g.router.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusNotFound)
		w.Write([]byte(`{"error":"Not Found","message":"The requested resource does not exist"}`))
	})
}

// proxyHandler returns a handler function that proxies requests to the destination
func (g *Gateway) proxyHandler(route struct {
	Path           string            `yaml:"path"`
	Destination    string            `yaml:"destination"`
	Methods        []string          `yaml:"methods"`
	RequireAuth    bool              `yaml:"requireAuth"`
	RateLimit      *int              `yaml:"rateLimit"`
	Timeout        *time.Duration    `yaml:"timeout"`
	Headers        map[string]string `yaml:"headers"`
	StripPath      bool              `yaml:"stripPath"`
	ValidateSchema string            `yaml:"validateSchema"`
}) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		// Parse the destination URL
		target, err := url.Parse(route.Destination)
		if err != nil {
			g.logger.Error("Failed to parse destination URL: %v", err)
			w.WriteHeader(http.StatusInternalServerError)
			w.Write([]byte(`{"error":"Internal Server Error"}`))
			return
		}

		// Create the reverse proxy
		proxy := httputil.NewSingleHostReverseProxy(target)

		// Customize the director function to modify the request
		originalDirector := proxy.Director
		proxy.Director = func(req *http.Request) {
			originalDirector(req)

			// Strip the path prefix if configured
			if route.StripPath {
				req.URL.Path = strings.TrimPrefix(req.URL.Path, route.Path)
				if req.URL.Path == "" {
					req.URL.Path = "/"
				}
			}

			// Add custom headers
			for key, value := range route.Headers {
				req.Header.Set(key, value)
			}

			// Add X-Forwarded headers
			req.Header.Set("X-Forwarded-Host", req.Host)
			req.Header.Set("X-Forwarded-For", getClientIP(req))

			// Add X-Request-ID for tracking
			if reqID := r.Header.Get("X-Request-ID"); reqID == "" {
				req.Header.Set("X-Request-ID", generateRequestID())
			} else {
				req.Header.Set("X-Request-ID", reqID)
			}
		}

		// Customize the error handler
		proxy.ErrorHandler = func(w http.ResponseWriter, r *http.Request, err error) {
			g.logger.Error("Proxy error: %v", err)
			w.WriteHeader(http.StatusBadGateway)
			w.Write([]byte(`{"error":"Bad Gateway","message":"Unable to reach the upstream service"}`))
		}

		// Customize the response writer to log and collect metrics
		lrw := newLoggingResponseWriter(w)

		// Execute the proxy
		proxy.ServeHTTP(lrw, r)

		// Record metrics
		duration := time.Since(start).Seconds()
		g.metrics.requestDuration.WithLabelValues(r.Method, route.Path).Observe(duration)
		g.metrics.requestCount.WithLabelValues(r.Method, route.Path, fmt.Sprintf("%d", lrw.statusCode)).Inc()
		g.metrics.responseSize.WithLabelValues(r.Method, route.Path).Observe(float64(lrw.bytesWritten))

		// Log the request
		g.logger.Info("%s %s %d %s %dB", r.Method, r.URL.Path, lrw.statusCode, time.Since(start), lrw.bytesWritten)
	}
}

// generateRequestID generates a unique request ID
func generateRequestID() string {
	return fmt.Sprintf("%d", time.Now().UnixNano())
}

// getClientIP gets the client IP address from the request
func getClientIP(r *http.Request) string {
	// Check for X-Forwarded-For header
	forwardedFor := r.Header.Get("X-Forwarded-For")
	if forwardedFor != "" {
		// X-Forwarded-For can contain multiple IPs, take the first one
		ips := strings.Split(forwardedFor, ",")
		return strings.TrimSpace(ips[0])
	}

	// Check for X-Real-IP header
	realIP := r.Header.Get("X-Real-IP")
	if realIP != "" {
		return realIP
	}

	// Fall back to RemoteAddr
	return strings.Split(r.RemoteAddr, ":")[0]
}

// loadPlugins loads and initializes all enabled plugins
func (g *Gateway) loadPlugins() error {
	for _, pluginConfig := range g.config.Plugins {
		if !pluginConfig.Enabled {
			g.logger.Info("Plugin %s is disabled, skipping", pluginConfig.Name)
			continue
		}

		g.logger.Info("Loading plugin: %s from %s", pluginConfig.Name, pluginConfig.Path)

		// Load the plugin
		plug, err := plugin.Open(pluginConfig.Path)
		if err != nil {
			return fmt.Errorf("failed to open plugin %s: %w", pluginConfig.Name, err)
		}

		// Look up the plugin's constructor
		symPlugin, err := plug.Lookup("Plugin")
		if err != nil {
			return fmt.Errorf("failed to lookup 'Plugin' symbol in %s: %w", pluginConfig.Name, err)
		}

		// Cast to the GatewayPlugin interface
		gatewayPlugin, ok := symPlugin.(GatewayPlugin)
		if !ok {
			return fmt.Errorf("plugin %s does not implement GatewayPlugin interface", pluginConfig.Name)
		}

		// Initialize the plugin with its configuration
		if err := gatewayPlugin.Initialize(pluginConfig.Config); err != nil {
			return fmt.Errorf("failed to initialize plugin %s: %w", pluginConfig.Name, err)
		}

		// Add the plugin to the list
		g.pluginsMu.Lock()
		g.plugins = append(g.plugins, gatewayPlugin)

		// Register the plugin's middleware
		middleware := gatewayPlugin.Middleware()
		if middleware != nil {
			g.middlewares = append(g.middlewares, middleware)
		}
		g.pluginsMu.Unlock()

		g.logger.Info("Plugin %s loaded successfully", pluginConfig.Name)
	}

	return nil
}

// Serve starts the gateway server
func (g *Gateway) Serve() error {
	// Apply core security middlewares first
	var handler http.Handler = g.router

	// Apply security middlewares
	handler = g.rateLimitMiddleware(handler)
	handler = g.ipWhitelistMiddleware(handler)
	handler = g.securityHeadersMiddleware(handler)
	handler = g.csrfMiddleware(handler)
	handler = g.requestSizeMiddleware(handler)

	// Apply plugin middlewares in reverse order (last added, first executed)
	for i := len(g.middlewares) - 1; i >= 0; i-- {
		handler = g.middlewares[i](handler)
	}

	// Add logging middleware if enabled
	if g.config.Server.EnableLogging {
		handler = g.loggingMiddleware(handler)
	}

	// Add metrics middleware
	handler = g.metricsMiddleware(handler)

	// Configure the server
	addr := fmt.Sprintf(":%d", g.config.Server.Port)
	server := &http.Server{
		Addr:         addr,
		Handler:      handler,
		ReadTimeout:  g.config.Server.ReadTimeout * time.Second,
		WriteTimeout: g.config.Server.WriteTimeout * time.Second,
		IdleTimeout:  g.config.Server.IdleTimeout * time.Second,
	}

	// Configure TLS if cert and key files are provided
	var tlsConfig *tls.Config
	if g.config.Server.TLSCertFile != "" && g.config.Server.TLSKeyFile != "" {
		tlsConfig = &tls.Config{
			MinVersion: tls.VersionTLS12,
			CipherSuites: []uint16{
				tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
				tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
				tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,
				tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
				tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
				tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
			},
			PreferServerCipherSuites: true,
		}

		// Configure mTLS if enabled and client CA cert is provided
		if g.config.Security.EnableMTLS && g.config.Server.ClientCACertFile != "" {
			caCert, err := os.ReadFile(g.config.Server.ClientCACertFile)
			if err != nil {
				return fmt.Errorf("failed to read client CA cert file: %w", err)
			}

			caCertPool := x509.NewCertPool()
			if !caCertPool.AppendCertsFromPEM(caCert) {
				return fmt.Errorf("failed to parse client CA cert file")
			}

			tlsConfig.ClientCAs = caCertPool
			tlsConfig.ClientAuth = tls.RequireAndVerifyClientCert
		}

		server.TLSConfig = tlsConfig
	}

	// Start metrics server on a separate port
	if g.config.Server.MetricsPort > 0 {
		metricsServer := &http.Server{
			Addr:    fmt.Sprintf(":%d", g.config.Server.MetricsPort),
			Handler: promhttp.Handler(),
		}

		go func() {
			g.logger.Info("Starting metrics server on :%d", g.config.Server.MetricsPort)
			if err := metricsServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
				g.logger.Error("Failed to start metrics server: %v", err)
			}
		}()
	}

	// Handle graceful shutdown
	done := make(chan os.Signal, 1)
	signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		g.logger.Info("Starting gateway server on %s", addr)
		var err error
		if server.TLSConfig != nil {
			err = server.ListenAndServeTLS(g.config.Server.TLSCertFile, g.config.Server.TLSKeyFile)
		} else {
			err = server.ListenAndServe()
		}

		if err != nil && err != http.ErrServerClosed {
			g.logger.Error("Failed to start server: %v", err)
			os.Exit(1)
		}
	}()

	<-done
	g.logger.Info("Server is shutting down...")

	// Shutdown plugins
	g.shutdownPlugins()

	// Create a deadline to wait for
	ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	defer cancel()

	if err := server.Shutdown(ctx); err != nil {
		return fmt.Errorf("server forced to shutdown: %w", err)
	}

	g.logger.Info("Server gracefully stopped")
	return nil
}

// metricsMiddleware collects metrics for requests
func (g *Gateway) metricsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Increment active connections
		activeConnections.Inc()
		defer activeConnections.Dec()

		// Create custom response writer to capture status code
		rw := newLoggingResponseWriter(w)

		// Start timer for request duration
		start := time.Now()

		// Call next handler
		next.ServeHTTP(rw, r)

		// Calculate duration
		duration := time.Since(start).Seconds()

		// Normalize the request path to avoid high cardinality in metrics
		route := mux.CurrentRoute(r)
		path := "unknown"
		if route != nil {
			// Try to get the route name, fall back to the template
			path = route.GetName()
			if path == "" {
				pathTemplate, err := route.GetPathTemplate()
				if err == nil {
					path = pathTemplate
				}
			}
		}

		// Record metrics
		statusCode := fmt.Sprintf("%d", rw.statusCode)
		httpRequestsTotal.WithLabelValues(statusCode, r.Method, path).Inc()
		httpRequestDuration.WithLabelValues(statusCode, r.Method, path).Observe(duration)
		httpResponseSize.WithLabelValues(statusCode, r.Method, path).Observe(float64(rw.bytesWritten))
	})
}

// shutdownPlugins gracefully shuts down all plugins
func (g *Gateway) shutdownPlugins() {
	g.pluginsMu.RLock()
	defer g.pluginsMu.RUnlock()

	for _, p := range g.plugins {
		if err := p.Shutdown(); err != nil {
			g.logger.Error("Error shutting down plugin %s: %v", p.Name(), err)
		} else {
			g.logger.Info("Plugin %s shutdown successfully", p.Name())
		}
	}
}

// timeoutMiddleware adds a timeout to the request context
func (g *Gateway) timeoutMiddleware(timeout time.Duration) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Create a context with timeout
			ctx, cancel := context.WithTimeout(r.Context(), timeout)
			defer cancel()

			// Create a channel to signal when the request has completed
			done := make(chan struct{})

			// Create a response writer that can detect when the response is complete
			lrw := newLoggingResponseWriter(w)

			// Process the request in a goroutine
			go func() {
				next.ServeHTTP(lrw, r.WithContext(ctx))
				close(done)
			}()

			// Wait for the request to complete or timeout
			select {
			case <-done:
				// Request completed normally
				return
			case <-ctx.Done():
				// Request timed out
				if ctx.Err() == context.DeadlineExceeded {
					w.WriteHeader(http.StatusGatewayTimeout)
					w.Write([]byte(`{"error":"Gateway Timeout","message":"Request processing timed out"}`))
				}
				return
			}
		})
	}
}

// validateRequestMiddleware validates request bodies against a JSON schema
func (g *Gateway) validateRequestMiddleware(schemaPath string) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Only validate POST, PUT, and PATCH requests with a Content-Type of application/json
			if (r.Method == http.MethodPost || r.Method == http.MethodPut || r.Method == http.MethodPatch) &&
				r.Header.Get("Content-Type") == "application/json" {

				// Read the request body
				body, err := io.ReadAll(r.Body)
				if err != nil {
					w.WriteHeader(http.StatusBadRequest)
					w.Write([]byte(`{"error":"Bad Request","message":"Unable to read request body"}`))
					return
				}

				// Close the original body
				r.Body.Close()

				// Create a new reader with the same body data
				r.Body = io.NopCloser(strings.NewReader(string(body)))

				// Check if the body is valid JSON
				var jsonData interface{}
				if err := json.Unmarshal(body, &jsonData); err != nil {
					w.WriteHeader(http.StatusBadRequest)
					w.Write([]byte(`{"error":"Bad Request","message":"Invalid JSON format"}`))
					return
				}

				// TODO: Add actual schema validation using a library like gojsonschema
				// This is a placeholder for now, as implementing full schema validation
				// would require adding a dependency

				// For now, let's just check if the schema file exists
				if _, err := os.Stat(schemaPath); os.IsNotExist(err) {
					g.logger.Error("Schema file not found: %s", schemaPath)
					// Continue processing even if schema file is missing
				}
			}

			next.ServeHTTP(w, r)
		})
	}
}

// authMiddleware handles authentication for protected routes
func (g *Gateway) authMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Check for Authorization header
		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			w.WriteHeader(http.StatusUnauthorized)
			w.Write([]byte(`{"error":"Unauthorized","message":"Missing authorization header"}`))
			return
		}

		// Simple token validation for now
		// In a real implementation, this would validate JWT tokens
		if !strings.HasPrefix(authHeader, "Bearer ") {
			w.WriteHeader(http.StatusUnauthorized)
			w.Write([]byte(`{"error":"Unauthorized","message":"Invalid authorization format"}`))
			return
		}

		// Extract the token
		token := strings.TrimPrefix(authHeader, "Bearer ")

		// TODO: Implement JWT token validation using the JWT secret from config
		// This is a placeholder for now
		if token == "" {
			w.WriteHeader(http.StatusUnauthorized)
			w.Write([]byte(`{"error":"Unauthorized","message":"Invalid token"}`))
			return
		}

		// For now, we'll just continue the request
		next.ServeHTTP(w, r)
	})
}

// rateLimitMiddleware implements rate limiting
func (g *Gateway) rateLimitMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Skip rate limiting if disabled
		if g.config.Security.RateLimitRequests <= 0 {
			next.ServeHTTP(w, r)
			return
		}

		// Get client IP
		clientIP := getClientIP(r)

		// Get current route
		route := mux.CurrentRoute(r)
		var routePath string
		if route != nil {
			var err error
			routePath, err = route.GetPathTemplate()
			if err != nil {
				routePath = r.URL.Path
			}
		} else {
			routePath = r.URL.Path
		}

		// Get appropriate limiter
		var limiter *rate.Limiter
		if routePath != "" {
			limiter = g.rateLimiter.GetRouteLimiter(routePath, clientIP)
		} else {
			limiter = g.rateLimiter.GetLimiter(clientIP)
		}

		// Check if request is allowed
		if !limiter.Allow() {
			w.Header().Set("Retry-After", "60")
			w.WriteHeader(http.StatusTooManyRequests)
			w.Write([]byte(`{"error":"Too Many Requests","message":"Rate limit exceeded"}`))
			return
		}

		next.ServeHTTP(w, r)
	})
}

// ipWhitelistMiddleware implements IP whitelisting
func (g *Gateway) ipWhitelistMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Skip IP whitelisting if disabled
		if !g.config.Security.EnableIPWhitelisting {
			next.ServeHTTP(w, r)
			return
		}

		// Get client IP
		clientIP := getClientIP(r)

		// Create whitelist checker
		whitelist := NewIPWhitelist(true, g.config.Security.WhitelistedIPs)

		// Check if IP is allowed
		if !whitelist.IsAllowed(clientIP) {
			w.WriteHeader(http.StatusForbidden)
			w.Write([]byte(`{"error":"Forbidden","message":"IP address not allowed"}`))
			return
		}

		next.ServeHTTP(w, r)
	})
}

// securityHeadersMiddleware adds security headers to responses
func (g *Gateway) securityHeadersMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Add security headers
		w.Header().Set("X-Content-Type-Options", "nosniff")
		w.Header().Set("X-Frame-Options", "DENY")

		// Add XSS protection header if enabled
		if g.config.Security.EnableXSS {
			w.Header().Set("X-XSS-Protection", "1; mode=block")
		}

		// Add HSTS header if enabled
		if g.config.Security.EnableHSTS {
			maxAge := g.config.Security.HSTSMaxAge
			if maxAge <= 0 {
				maxAge = 31536000 // Default to 1 year
			}
			w.Header().Set("Strict-Transport-Security", fmt.Sprintf("max-age=%d; includeSubDomains", maxAge))
		}

		// Set content security policy
		w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self'; object-src 'none'; img-src 'self'; style-src 'self';")

		next.ServeHTTP(w, r)
	})
}

// csrfMiddleware implements CSRF protection
func (g *Gateway) csrfMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Skip CSRF protection if disabled or for non-mutating methods
		if !g.config.Security.EnableCSRF || (r.Method != http.MethodPost && r.Method != http.MethodPut && r.Method != http.MethodPatch && r.Method != http.MethodDelete) {
			next.ServeHTTP(w, r)
			return
		}

		// Check for CSRF token in header
		csrfToken := r.Header.Get("X-CSRF-Token")
		if csrfToken == "" {
			w.WriteHeader(http.StatusForbidden)
			w.Write([]byte(`{"error":"Forbidden","message":"Missing CSRF token"}`))
			return
		}

		// TODO: Implement proper CSRF token validation
		// This is a placeholder for now

		next.ServeHTTP(w, r)
	})
}

// requestSizeMiddleware limits the size of request bodies
func (g *Gateway) requestSizeMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Skip if request size validation is disabled or if there's no request body
		if !g.config.Security.EnableRequestValidation || r.ContentLength == 0 {
			next.ServeHTTP(w, r)
			return
		}

		// Check if request body is too large
		maxSize := g.config.Security.MaxRequestBodySize
		if maxSize > 0 && r.ContentLength > maxSize {
			w.WriteHeader(http.StatusRequestEntityTooLarge)
			w.Write([]byte(`{"error":"Request Entity Too Large","message":"Request body exceeds maximum size"}`))
			return
		}

		next.ServeHTTP(w, r)
	})
}

// loggingMiddleware logs requests
func (g *Gateway) loggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		// Create a custom response writer to capture the status code
		lrw := newLoggingResponseWriter(w)

		// Call the next handler
		next.ServeHTTP(lrw, r)

		// Log the request
		g.logger.Info("%s %s %d %s %dB", r.Method, r.URL.Path, lrw.statusCode, time.Since(start), lrw.bytesWritten)
	})
}

// loggingResponseWriter is a custom response writer that captures the status code
type loggingResponseWriter struct {
	http.ResponseWriter
	statusCode   int
	bytesWritten int
}

// newLoggingResponseWriter creates a new logging response writer
func newLoggingResponseWriter(w http.ResponseWriter) *loggingResponseWriter {
	return &loggingResponseWriter{w, http.StatusOK, 0}
}

// WriteHeader captures the status code
func (lrw *loggingResponseWriter) WriteHeader(code int) {
	lrw.statusCode = code
	lrw.ResponseWriter.WriteHeader(code)
}

// Write captures the number of bytes written
func (lrw *loggingResponseWriter) Write(b []byte) (int, error) {
	n, err := lrw.ResponseWriter.Write(b)
	lrw.bytesWritten += n
	return n, err
}

// main is the entry point for the API gateway
func main() {
	// Parse command line flags
	configPath := flag.String("config", "config.yaml", "Path to the configuration file")
	flag.Parse()

	// Initialize the gateway
	gateway, err := NewGateway(*configPath)
	if err != nil {
		log.Fatalf("Failed to initialize gateway: %v", err)
	}

	// Start the gateway server
	if err := gateway.Serve(); err != nil {
		log.Fatalf("Gateway server failed: %v", err)
	}
}
