package main

import (
	"context"
	"crypto/tls"
	"errors"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"plugin"
	"sync"
	"syscall"
	"time"

	"github.com/gorilla/mux"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/sirupsen/logrus"
	"github.com/ulule/limiter/v3"
	"github.com/ulule/limiter/v3/drivers/store/memory"
	"golang.org/x/crypto/acme/autocert"
	"gopkg.in/yaml.v3"
)

// Version information
var (
	Version   = "1.0.0"
	BuildTime = "unknown"
	GitCommit = "unknown"
)

// Config represents the gateway configuration
type Config struct {
	Server struct {
		Port             int           `yaml:"port"`
		SSLPort          int           `yaml:"sslPort"`
		ReadTimeout      time.Duration `yaml:"readTimeout"`
		WriteTimeout     time.Duration `yaml:"writeTimeout"`
		IdleTimeout      time.Duration `yaml:"idleTimeout"`
		PluginsDir       string        `yaml:"pluginsDir"`
		EnableLogging    bool          `yaml:"enableLogging"`
		LogLevel         string        `yaml:"logLevel"`
		LogFormat        string        `yaml:"logFormat"`
		MetricsEnabled   bool          `yaml:"metricsEnabled"`
		MetricsPath      string        `yaml:"metricsPath"`
		EnableHTTPS      bool          `yaml:"enableHTTPS"`
		CertFile         string        `yaml:"certFile"`
		KeyFile          string        `yaml:"keyFile"`
		EnableAutoCert   bool          `yaml:"enableAutoCert"`
		AutoCertDomains  []string      `yaml:"autoCertDomains"`
		AutoCertEmail    string        `yaml:"autoCertEmail"`
		AutoCertCacheDir string        `yaml:"autoCertCacheDir"`
	} `yaml:"server"`

	Security struct {
		EnableCORS                   bool     `yaml:"enableCORS"`
		CORSAllowedOrigins           []string `yaml:"corsAllowedOrigins"`
		CORSAllowedMethods           []string `yaml:"corsAllowedMethods"`
		CORSAllowedHeaders           []string `yaml:"corsAllowedHeaders"`
		EnableCSP                    bool     `yaml:"enableCSP"`
		CSPDirectives                string   `yaml:"cspDirectives"`
		EnableXSSProtection          bool     `yaml:"enableXSSProtection"`
		EnableFrameOptions           bool     `yaml:"enableFrameOptions"`
		EnableHSTS                   bool     `yaml:"enableHSTS"`
		HSTSMaxAge                   int      `yaml:"hstsMaxAge"`
		EnableRateLimiting           bool     `yaml:"enableRateLimiting"`
		RateLimitRequests            int64    `yaml:"rateLimitRequests"`
		RateLimitPeriod              string   `yaml:"rateLimitPeriod"`
		EnableJWTAuth                bool     `yaml:"enableJWTAuth"`
		JWTSecret                    string   `yaml:"jwtSecret"`
		JWTAlgorithm                 string   `yaml:"jwtAlgorithm"`
		EnableAPIKeys                bool     `yaml:"enableAPIKeys"`
		APIKeysHeader                string   `yaml:"apiKeysHeader"`
		APIKeys                      []string `yaml:"apiKeys"`
		TrustedProxies               []string `yaml:"trustedProxies"`
		EnableRequestValidation      bool     `yaml:"enableRequestValidation"`
		EnableResponseSanitization   bool     `yaml:"enableResponseSanitization"`
		EnableRequestBodySizeLimit   bool     `yaml:"enableRequestBodySizeLimit"`
		RequestBodySizeLimitBytes    int64    `yaml:"requestBodySizeLimitBytes"`
		EnableSecurityHeaders        bool     `yaml:"enableSecurityHeaders"`
		EnableIPWhitelisting         bool     `yaml:"enableIPWhitelisting"`
		WhitelistedIPs               []string `yaml:"whitelistedIPs"`
		EnableRequestTimeout         bool     `yaml:"enableRequestTimeout"`
		RequestTimeoutDuration       string   `yaml:"requestTimeoutDuration"`
		EnableCircuitBreaker         bool     `yaml:"enableCircuitBreaker"`
		CircuitBreakerThreshold      int      `yaml:"circuitBreakerThreshold"`
		CircuitBreakerTimeout        string   `yaml:"circuitBreakerTimeout"`
		EnableAccessLogs             bool     `yaml:"enableAccessLogs"`
		AccessLogsPath               string   `yaml:"accessLogsPath"`
		EnableAuditLogs              bool     `yaml:"enableAuditLogs"`
		AuditLogsPath                string   `yaml:"auditLogsPath"`
		HeadersToAudit               []string `yaml:"headersToAudit"`
		EnableTLSMinVersion          bool     `yaml:"enableTLSMinVersion"`
		TLSMinVersion                string   `yaml:"tlsMinVersion"`
		EnablePanicRecovery          bool     `yaml:"enablePanicRecovery"`
		EnableSignatureVerification  bool     `yaml:"enableSignatureVerification"`
		SignatureHeader              string   `yaml:"signatureHeader"`
		SignatureSecret              string   `yaml:"signatureSecret"`
		BackendTLSVerification       bool     `yaml:"backendTLSVerification"`
		BackendConnectionTimeout     string   `yaml:"backendConnectionTimeout"`
		BackendResponseTimeout       string   `yaml:"backendResponseTimeout"`
		EnableHealthCheck            bool     `yaml:"enableHealthCheck"`
		HealthCheckPath              string   `yaml:"healthCheckPath"`
		HealthCheckInterval          string   `yaml:"healthCheckInterval"`
	} `yaml:"security"`

	Routes []struct {
		Path                  string                 `yaml:"path"`
		Destination           string                 `yaml:"destination"`
		Methods               []string               `yaml:"methods"`
		Auth                  bool                   `yaml:"auth"`
		RateLimitOverride     int64                  `yaml:"rateLimitOverride"`
		TimeoutOverride       string                 `yaml:"timeoutOverride"`
		HeaderTransformation  map[string]string      `yaml:"headerTransformation"`
		RequiredScopes        []string               `yaml:"requiredScopes"`
		CustomResponseHeaders map[string]string      `yaml:"customResponseHeaders"`
		CustomConfig          map[string]interface{} `yaml:"customConfig"`
		BodySizeLimitBytes    int64                  `yaml:"bodySizeLimitBytes"`
		CircuitBreakerEnabled bool                   `yaml:"circuitBreakerEnabled"`
		IPWhitelistOnly       bool                   `yaml:"ipWhitelistOnly"`
		CacheTTL              string                 `yaml:"cacheTTL"`
	} `yaml:"routes"`

	Plugins []struct {
		Name    string                 `yaml:"name"`
		Path    string                 `yaml:"path"`
		Enabled bool                   `yaml:"enabled"`
		Config  map[string]interface{} `yaml:"config"`
	} `yaml:"plugins"`
}

// GatewayPlugin interface that all plugins must implement
type GatewayPlugin interface {
	Name() string
	Initialize(config map[string]interface{}) error
	Middleware() func(http.Handler) http.Handler
	Shutdown() error
}

// Gateway is the main API gateway struct
type Gateway struct {
	config         *Config
	router         *mux.Router
	plugins        []GatewayPlugin
	pluginsMu      sync.RWMutex
	middlewares    []func(http.Handler) http.Handler
	logger         *logrus.Logger
	accessLogger   *logrus.Logger
	auditLogger    *logrus.Logger
	metricsEnabled bool
	rateLimiter    *limiter.Limiter
	rateLimitStore limiter.Store
	shutdownHooks  []func() error
}

// Custom response writer to capture the status code and response size
type responseWriter struct {
	http.ResponseWriter
	statusCode int
	size       int
}

func newResponseWriter(w http.ResponseWriter) *responseWriter {
	return &responseWriter{
		ResponseWriter: w,
		statusCode:     http.StatusOK,
	}
}

func (rw *responseWriter) WriteHeader(code int) {
	rw.statusCode = code
	rw.ResponseWriter.WriteHeader(code)
}

func (rw *responseWriter) Write(b []byte) (int, error) {
	size, err := rw.ResponseWriter.Write(b)
	rw.size += size
	return size, err
}

// Define metrics
var (
	httpRequestsTotal = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "gateway_http_requests_total",
			Help: "Count of all HTTP requests",
		},
		[]string{"code", "method", "path"},
	)
	httpRequestDuration = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "gateway_http_request_duration_seconds",
			Help:    "Duration of HTTP requests in seconds",
			Buckets: prometheus.DefBuckets,
		},
		[]string{"code", "method", "path"},
	)
	httpResponseSize = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "gateway_http_response_size_bytes",
			Help:    "Size of HTTP responses in bytes",
			Buckets: []float64{100, 1000, 10000, 100000, 1000000},
		},
		[]string{"code", "method", "path"},
	)
	activeConnections = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "gateway_active_connections",
			Help: "Number of active connections",
		},
	)
	circuitBreakerStatus = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "gateway_circuit_breaker_status",
			Help: "Status of circuit breaker (0=closed, 1=open)",
		},
		[]string{"destination"},
	)
)

// NewGateway creates a new API gateway instance
func NewGateway(configPath string) (*Gateway, error) {
	config, err := loadConfig(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load config: %w", err)
	}

	gateway := &Gateway{
		config:        config,
		router:        mux.NewRouter(),
		plugins:       make([]GatewayPlugin, 0),
		middlewares:   make([]func(http.Handler) http.Handler, 0),
		logger:        setupLogger(config),
		shutdownHooks: make([]func() error, 0),
	}

	// Initialize rate limiter if enabled
	if config.Security.EnableRateLimiting {
		period, err := time.ParseDuration(config.Security.RateLimitPeriod)
		if err != nil {
			return nil, fmt.Errorf("invalid rate limit period: %w", err)
		}
		rate := limiter.Rate{
			Period: period,
			Limit:  config.Security.RateLimitRequests,
		}
		gateway.rateLimitStore = memory.NewStore()
		gateway.rateLimiter = limiter.New(gateway.rateLimitStore, rate)
	}

	// Initialize access logger if enabled
	if config.Security.EnableAccessLogs {
		gateway.accessLogger = setupAccessLogger(config)
	}

	// Initialize audit logger if enabled
	if config.Security.EnableAuditLogs {
		gateway.auditLogger = setupAuditLogger(config)
	}

	// Initialize prometheus metrics
	if config.Server.MetricsEnabled {
		gateway.metricsEnabled = true
		prometheus.MustRegister(httpRequestsTotal)
		prometheus.MustRegister(httpRequestDuration)
		prometheus.MustRegister(httpResponseSize)
		prometheus.MustRegister(activeConnections)
		prometheus.MustRegister(circuitBreakerStatus)
	}

	// Set up the router
	gateway.setupRoutes()

	// Load plugins
	if err := gateway.loadPlugins(); err != nil {
		return nil, fmt.Errorf("failed to load plugins: %w", err)
	}

	return gateway, nil
}

// setupLogger initializes and configures the logger
func setupLogger(config *Config) *logrus.Logger {
	logger := logrus.New()

	// Configure log level
	level, err := logrus.ParseLevel(config.Server.LogLevel)
	if err != nil {
		level = logrus.InfoLevel
	}
	logger.SetLevel(level)

	// Configure log format
	if config.Server.LogFormat == "json" {
		logger.SetFormatter(&logrus.JSONFormatter{
			TimestampFormat: time.RFC3339,
		})
	} else {
		logger.SetFormatter(&logrus.TextFormatter{
			TimestampFormat: time.RFC3339,
			FullTimestamp:   true,
		})
	}

	return logger
}

// setupAccessLogger initializes the access logger
func setupAccessLogger(config *Config) *logrus.Logger {
	logger := logrus.New()
	logger.SetFormatter(&logrus.JSONFormatter{
		TimestampFormat: time.RFC3339,
	})

	// Configure file output if path is provided
	if config.Security.AccessLogsPath != "" {
		// Ensure directory exists
		dir := filepath.Dir(config.Security.AccessLogsPath)
		if err := os.MkdirAll(dir, 0755); err != nil {
			log.Printf("Failed to create access log directory: %v", err)
		} else {
			file, err := os.OpenFile(config.Security.AccessLogsPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
			if err == nil {
				logger.SetOutput(file)
			} else {
				log.Printf("Failed to open access log file: %v", err)
			}
		}
	}

	return logger
}

// setupAuditLogger initializes the audit logger
func setupAuditLogger(config *Config) *logrus.Logger {
	logger := logrus.New()
	logger.SetFormatter(&logrus.JSONFormatter{
		TimestampFormat: time.RFC3339,
	})

	// Configure file output if path is provided
	if config.Security.AuditLogsPath != "" {
		// Ensure directory exists
		dir := filepath.Dir(config.Security.AuditLogsPath)
		if err := os.MkdirAll(dir, 0755); err != nil {
			log.Printf("Failed to create audit log directory: %v", err)
		} else {
			file, err := os.OpenFile(config.Security.AuditLogsPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
			if err == nil {
				logger.SetOutput(file)
			} else {
				log.Printf("Failed to open audit log file: %v", err)
			}
		}
	}

	return logger
}

// loadConfig loads the gateway configuration from a YAML file
func loadConfig(path string) (*Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var config Config
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, err
	}

	return &config, nil
}

// setupRoutes configures the routes from the config
func (g *Gateway) setupRoutes() {
	// Setup health check endpoint if enabled
	if g.config.Security.EnableHealthCheck {
		g.router.HandleFunc(g.config.Security.HealthCheckPath, g.healthCheckHandler()).
			Methods("GET")
	}

	// Setup metrics endpoint if enabled
	if g.config.Server.MetricsEnabled {
		g.router.Handle(g.config.Server.MetricsPath, promhttp.Handler()).
			Methods("GET")
	}

	// Setup version endpoint
	g.router.HandleFunc("/version", g.versionHandler()).
		Methods("GET")

	// Setup API routes
	for _, route := range g.config.Routes {
		g.router.HandleFunc(route.Path, g.proxyHandler(route)).
			Methods(route.Methods...)
	}

	// Add catch-all route for 404s
	g.router.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusNotFound)
		w.Write([]byte("404 - Route not found"))
	})
}

// healthCheckHandler returns a handler for health check requests
func (g *Gateway) healthCheckHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Add basic health check response
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(`{"status":"UP","version":"` + Version + `"}`))
	}
}

// versionHandler returns a handler for version information
func (g *Gateway) versionHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(fmt.Sprintf(`{"version":"%s","buildTime":"%s","commit":"%s"}`, 
			Version, BuildTime, GitCommit)))
	}
}

// proxyHandler returns a handler function that proxies requests to the destination
func (g *Gateway) proxyHandler(routeConfig struct {
	Path                  string                 `yaml:"path"`
	Destination           string                 `yaml:"destination"`
	Methods               []string               `yaml:"methods"`
	Auth                  bool                   `yaml:"auth"`
	RateLimitOverride     int64                  `yaml:"rateLimitOverride"`
	TimeoutOverride       string                 `yaml:"timeoutOverride"`
	HeaderTransformation  map[string]string      `yaml:"headerTransformation"`
	RequiredScopes        []string               `yaml:"requiredScopes"`
	CustomResponseHeaders map[string]string      `yaml:"customResponseHeaders"`
	CustomConfig          map[string]interface{} `yaml:"customConfig"`
	BodySizeLimitBytes    int64                  `yaml:"bodySizeLimitBytes"`
	CircuitBreakerEnabled bool                   `yaml:"circuitBreakerEnabled"`
	IPWhitelistOnly       bool                   `yaml:"ipWhitelistOnly"`
	CacheTTL              string                 `yaml:"cacheTTL"`
}) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Route-specific rate limit check if rate limiting is enabled
		if g.config.Security.EnableRateLimiting && routeConfig.RateLimitOverride > 0 {
			// Use the route-specific rate limit
			// In a real implementation, we would create a route-specific limiter
			limiterCtx, err := g.rateLimiter.Get(r.Context(), getClientIP(r, g.config.Security.TrustedProxies))
			if err != nil {
				g.logger.WithError(err).Error("Failed to check rate limit")
				http.Error(w, "Internal Server Error", http.StatusInternalServerError)
				return
			}

			if limiterCtx.Reached {
				w.Header().Set("X-RateLimit-Limit", fmt.Sprintf("%d", limiterCtx.Limit))
				w.Header().Set("X-RateLimit-Remaining", fmt.Sprintf("%d", limiterCtx.Remaining))
				w.Header().Set("X-RateLimit-Reset", fmt.Sprintf("%d", limiterCtx.Reset))
				http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
				return
			}

			// Set rate limit headers
			w.Header().Set("X-RateLimit-Limit", fmt.Sprintf("%d", limiterCtx.Limit))
			w.Header().Set("X-RateLimit-Remaining", fmt.Sprintf("%d", limiterCtx.Remaining))
			w.Header().Set("X-RateLimit-Reset", fmt.Sprintf("%d", limiterCtx.Reset))
		}

		// Check if IP whitelisting is enabled for this route
		if g.config.Security.EnableIPWhitelisting && routeConfig.IPWhitelistOnly {
			clientIP := getClientIP(r, g.config.Security.TrustedProxies)
			allowed := false
			for _, ip := range g.config.Security.WhitelistedIPs {
				if ip == clientIP {
					allowed = true
					break
				}
			}
			
			if !allowed {
				g.logger.WithField("ip", clientIP).Warn("Blocked request from non-whitelisted IP")
				http.Error(w, "Forbidden", http.StatusForbidden)
				return
			}
		}

		// Check for body size limit
		bodySizeLimit := g.config.Security.RequestBodySizeLimitBytes
		if routeConfig.BodySizeLimitBytes > 0 {
			bodySizeLimit = routeConfig.BodySizeLimitBytes
		}
		
		if g.config.Security.EnableRequestBodySizeLimit && bodySizeLimit > 0 && r.ContentLength > bodySizeLimit {
			g.logger.WithFields(logrus.Fields{
				"content_length": r.ContentLength,
				"limit": bodySizeLimit,
			}).Warn("Request body too large")
			http.Error(w, "Request entity too large", http.StatusRequestEntityTooLarge)
			return
		}

		// Apply header transformations
		for k, v := range routeConfig.HeaderTransformation {
			r.Header.Set(k, v)
		}

		// Audit sensitive headers if enabled
		if g.config.Security.EnableAuditLogs && g.auditLogger != nil {
			auditEvent := logrus.Fields{
				"timestamp": time.Now().Format(time.RFC3339),
				"method":    r.Method,
				"path":      r.URL.Path,
				"client_ip": getClientIP(r, g.config.Security.TrustedProxies),
				"user_agent": r.UserAgent(),
			}
			
			// Add audited headers
			for _, header := range g.config.Security.HeadersToAudit {
				if value := r.Header.Get(header); value != "" {
					auditEvent[header] = value
				}
			}
			
			g.auditLogger.WithFields(auditEvent).Info("API Request")
		}

		// In a real implementation, this would proxy the request to the destination
		// with proper error handling, retries, circuit breaker, etc.
		// For simplicity, we'll just return a placeholder response
		
		// Set custom response headers if defined
		for k, v := range routeConfig.CustomResponseHeaders {
			w.Header().Set(k, v)
		}
		
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(fmt.Sprintf("Request would be proxied to %s", routeConfig.Destination)))
	}
}

// getClientIP extracts the real client IP considering X-Forwarded-For if from trusted proxy
func getClientIP(r *http.Request, trustedProxies []string) string {
	// Check if the request is from a trusted proxy
	remoteIP := r.RemoteAddr
	
	// Check if we should trust the X-Forwarded-For header
	for _, trustedIP := range trustedProxies {
		if remoteIP == trustedIP {
			// If request is from trusted proxy, get the real client IP from X-Forwarded-For
			if forwardedFor := r.Header.Get("X-Forwarded-For"); forwardedFor != "" {
				// Extract the first IP which is the client IP
				return forwardedFor
			}
			break
		}
	}
	
	return remoteIP
}

// loadPlugins loads and initializes all enabled plugins
func (g *Gateway) loadPlugins() error {
	// Check if plugins directory exists
	if g.config.Server.PluginsDir != "" {
		if _, err := os.Stat(g.config.Server.PluginsDir); os.IsNotExist(err) {
			g.logger.Warnf("Plugins directory %s does not exist", g.config.Server.PluginsDir)
			return nil
		}
	}

	for _, pluginConfig := range g.config.Plugins {
		if !pluginConfig.Enabled {
			g.logger.Infof("Plugin %s is disabled, skipping", pluginConfig.Name)
			continue
		}

		g.logger.Infof("Loading plugin: %s from %s", pluginConfig.Name, pluginConfig.Path)

		// Validate plugin file exists
		if _, err := os.Stat(pluginConfig.Path); os.IsNotExist(err) {
			return fmt.Errorf("plugin file %s does not exist", pluginConfig.Path)
		}

		// Load the plugin
		plug, err := plugin.Open(pluginConfig.Path)
		if err != nil {
			return fmt.Errorf("failed to open plugin %s: %w", pluginConfig.Name, err)
		}

		// Look up the plugin's constructor with security check
		symPlugin, err := plug.Lookup("Plugin")
		if err != nil {
			return fmt.Errorf("failed to lookup 'Plugin' symbol in %s: %w", pluginConfig.Name, err)
		}

		// Cast to the GatewayPlugin interface
		gatewayPlugin, ok := symPlugin.(GatewayPlugin)
		if !ok {
			return fmt.Errorf("plugin %s does not implement GatewayPlugin interface", pluginConfig.Name)
		}

		// Validate plugin name matches expected name (additional security check)
		if gatewayPlugin.Name() != pluginConfig.Name {
			return fmt.Errorf("plugin name mismatch: expected %s, got %s", pluginConfig.Name, gatewayPlugin.Name())
		}

		// Initialize the plugin with its configuration
		if err := gatewayPlugin.Initialize(pluginConfig.Config); err != nil {
			return fmt.Errorf("failed to initialize plugin %s: %w", pluginConfig.Name, err)
		}

		// Add the plugin to the list
		g.pluginsMu.Lock()
		g.plugins = append(g.plugins, gatewayPlugin)

		// Register the plugin's middleware
		middleware := gatewayPlugin.Middleware()
		if middleware != nil {
			g.middlewares = append(g.middlewares, middleware)
		}
		g.pluginsMu.Unlock()

		g.logger.Infof("Plugin %s loaded successfully", pluginConfig.Name)
	}

	return nil
}

// setupSecurityMiddleware configures security-related middleware
func (g *Gateway) setupSecurityMiddleware() []func(http.Handler) http.Handler {
	var securityMiddleware []func(http.Handler) http.Handler

	// Add panic recovery middleware
	if g.config.Security.EnablePanicRecovery {
		securityMiddleware = append(securityMiddleware, g.panicRecoveryMiddleware)
	}

	// Add request timeout middleware
	if g.config.Security.EnableRequestTimeout {
		securityMiddleware = append(securityMiddleware, g.requestTimeoutMiddleware)
	}

	// Add CORS middleware
	if g.config.Security.EnableCORS {
		securityMiddleware = append(securityMiddleware, g.corsMiddleware)
	}

	// Add security headers middleware
	if g.config.Security.EnableSecurityHeaders {
		securityMiddleware = append(securityMiddleware, g.securityHeadersMiddleware)
	}

	// Add rate limit middleware
	if g.config.Security.EnableRateLimiting {
		securityMiddleware = append(securityMiddleware, g.rateLimitMiddleware)
	}

	// Add IP whitelist middleware
	if g.config.Security.EnableIPWhitelisting {
		securityMiddleware = append(securityMiddleware, g.ipWhitelistMiddleware)
	}

	// Add API key authentication middleware
	if g.config.Security.EnableAPIKeys {
		securityMiddleware = append(securityMiddleware, g.apiKeyMiddleware)
	}

	// Add JWT authentication middleware
	if g.config.Security.EnableJWTAuth {
		securityMiddleware = append(securityMiddleware, g.jwtAuthMiddleware)
	}

	// Add request validation middleware
	if g.config.Security.EnableRequestValidation {
		securityMiddleware = append(securityMiddleware, g.requestValidationMiddleware)
	}

	// Add response security middleware
	if g.config.Security.EnableResponseSanitization {
		securityMiddleware = append(securityMiddleware, g.responseSanitizationMiddleware)
	}

	return securityMiddleware
}

// Middleware implementations

// metricsMiddleware collects metrics for requests
func (g *Gateway) metricsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Increment active connections
		activeConnections.Inc()
		defer activeConnections.Dec()

		// Create custom response writer to capture status code
		rw := newResponseWriter(w)

		// Start timer for request duration
		start := time.Now()

		// Call next handler
		next.ServeHTTP(rw, r)

		// Calculate duration
		duration := time.Since(start).Seconds()

		// Normalize the request path to avoid high cardinality in metrics
		path := mux.CurrentRoute(r).GetName()
		if path == "" {
			path = "unknown"
		}

		// Record metrics
		statusCode := fmt.Sprintf("%d", rw.statusCode)
		httpRequestsTotal.WithLabelValues(statusCode, r.Method, path).Inc()
		httpRequestDuration.WithLabelValues(statusCode, r.Method, path).Observe(duration)
		httpResponseSize.WithLabelValues(statusCode, r.Method, path).Observe(float64(rw.size))
	})
}

// loggingMiddleware logs incoming requests
func (g *Gateway) loggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		rw := newResponseWriter(w)
		next.ServeHTTP(rw, r)

		duration := time.Since(start)

		// Main application log
		g.logger.WithFields(logrus.Fields{
			"method":     r.Method,
			"path":       r.URL.Path,
			"status":     rw.statusCode,
			"duration":   duration.String(),
			"user_agent": r.UserAgent(),
			"client_ip":  getClientIP(r, g.config.Security.TrustedProxies),
		}).Info("Request processed")

		// Access log
		if g.config.Security.EnableAccessLogs && g.accessLogger != nil {
			g.accessLogger.WithFields(logrus.Fields{
				"timestamp":  time.Now().Format(time.RFC3339),
				"method":     r.Method,
				"path":       r.URL.Path,
				"status":     rw.statusCode,
				"duration":   duration.String(),
				"size":       rw.size,
				"user_agent": r.UserAgent(),
				"client_ip":  getClientIP(r, g.config.Security.TrustedProxies),
				"referer":    r.Referer(),
			}).Info("Access")
		}
	})
}

// corsMiddleware adds CORS headers to responses
func (g *Gateway) corsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Set CORS headers
		if g.config.Security.EnableCORS {
			// Check if origin is allowed
			origin := r.Header.Get("Origin")
			allowedOrigin := "null"

			// If the origin is in the allowed list, set it as the allowed origin
			for _, allowed := range g.config.Security.CORSAllowedOrigins {
				if allowed == "*" || allowed == origin {
					allowedOrigin = origin
					break
				}
			}

			w.Header().Set("Access-Control-Allow-Origin", allowedOrigin)
			w.Header().Set("Access-Control-Allow-Methods", 
				formatCommaSeparatedList(g.config.Security.CORSAllowedMethods))
			w.Header().Set("Access-Control-Allow-Headers", 
				formatCommaSeparatedList(g.config.Security.CORSAllowedHeaders))
			w.Header().Set("Access-Control-Max-Age", "86400") // 24 hours

			// Handle preflight requests
			if r.Method == http.MethodOptions {
				w.WriteHeader(http.StatusNoContent)
				return
			}
		}

		next.ServeHTTP(w, r)
	})
}

// formatCommaSeparatedList joins a slice of strings into a comma-separated string
func formatCommaSeparatedList(slice []string) string {
	if len(slice) == 0 {
		return ""
	}
	return strings.Join(slice, ", ")
}

// securityHeadersMiddleware adds security headers to responses
func (g *Gateway) securityHeadersMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Add security headers
		if g.config.Security.EnableSecurityHeaders {
			// Content-Security-Policy
			if g.config.Security.EnableCSP {
				w.Header().Set("Content-Security-Policy", g.config.Security.CSPDirectives)
			}

			// X-XSS-Protection
			if g.config.Security.EnableXSSProtection {
				w.Header().Set("X-XSS-Protection", "1; mode=block")
			}

			// X-Frame-Options
			if g.config.Security.EnableFrameOptions {
				w.Header().Set("X-Frame-Options", "DENY")
			}

			// X-Content-Type-Options
			w.Header().Set("X-Content-Type-Options", "nosniff")

			// Strict-Transport-Security
			if g.config.Security.EnableHSTS {
				w.Header().Set("Strict-Transport-Security", 
					fmt.Sprintf("max-age=%d; includeSubDomains; preload", g.config.Security.HSTSMaxAge))
			}

			// Referrer-Policy
			w.Header().Set("Referrer-Policy", "strict-origin-when-cross-origin")

			// Permissions-Policy (formerly Feature-Policy)
			w.Header().Set("Permissions-Policy", 
				"camera=(), microphone=(), geolocation=(), interest-cohort=()")
		}

		next.ServeHTTP(w, r)
	})
}

// rateLimitMiddleware implements rate limiting
func (g *Gateway) rateLimitMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if g.config.Security.EnableRateLimiting {
			// Get client IP
			clientIP := getClientIP(r, g.config.Security.TrustedProxies)
			
			// Check rate limit
			limiterCtx, err := g.rateLimiter.Get(r.Context(), clientIP)
			if err != nil {
				g.logger.WithError(err).Error("Failed to check rate limit")
				http.Error(w, "Internal Server Error", http.StatusInternalServerError)
				return
			}

			if limiterCtx.Reached {
				w.Header().Set("X-RateLimit-Limit", fmt.Sprintf("%d", limiterCtx.Limit))
				w.Header().Set("X-RateLimit-Remaining", fmt.Sprintf("%d", limiterCtx.Remaining))
				w.Header().Set("X-RateLimit-Reset", fmt.Sprintf("%d", limiterCtx.Reset))
				w.Header().Set("Retry-After", fmt.Sprintf("%d", limiterCtx.Reset))
				http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
				return
			}

			// Set rate limit headers
			w.Header().Set("X-RateLimit-Limit", fmt.Sprintf("%d", limiterCtx.Limit))
			w.Header().Set("X-RateLimit-Remaining", fmt.Sprintf("%d", limiterCtx.Remaining))
			w.Header().Set("X-RateLimit-Reset", fmt.Sprintf("%d", limiterCtx.Reset))
		}

		next.ServeHTTP(w, r)
	})
}

// ipWhitelistMiddleware checks if client IP is in whitelist
func (g *Gateway) ipWhitelistMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Global IP whitelisting check
		if g.config.Security.EnableIPWhitelisting && len(g.config.Security.WhitelistedIPs) > 0 {
			clientIP := getClientIP(r, g.config.Security.TrustedProxies)
			allowed := false

			// Skip IP check for endpoints that should always be accessible
			currentPath := r.URL.Path
			if currentPath == g.config.Security.HealthCheckPath || 
			   currentPath == g.config.Server.MetricsPath || 
			   currentPath == "/version" {
				allowed = true
			} else {
				// Check if IP is in whitelist
				for _, ip := range g.config.Security.WhitelistedIPs {
					if ip == clientIP {
						allowed = true
						break
					}
				}
			}

			if !allowed {
				g.logger.WithField("ip", clientIP).Warn("Blocked request from non-whitelisted IP")
				http.Error(w, "Forbidden", http.StatusForbidden)
				return
			}
		}

		next.ServeHTTP(w, r)
	})
}

// apiKeyMiddleware validates API keys
func (g *Gateway) apiKeyMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if g.config.Security.EnableAPIKeys {
			apiKey := r.Header.Get(g.config.Security.APIKeysHeader)
			if apiKey == "" {
				g.logger.Warn("Missing API key")
				http.Error(w, "Unauthorized", http.StatusUnauthorized)
				return
			}

			valid := false
			for _, key := range g.config.Security.APIKeys {
				// In production, compare against securely hashed/encrypted keys
				if key == apiKey {
					valid = true
					break
				}
			}

			if !valid {
				g.logger.Warn("Invalid API key")
				http.Error(w, "Unauthorized", http.StatusUnauthorized)
				return
			}
		}

		next.ServeHTTP(w, r)
	})
}

// jwtAuthMiddleware validates JWT tokens
func (g *Gateway) jwtAuthMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if g.config.Security.EnableJWTAuth {
			// Extract token from Authorization header
			authHeader := r.Header.Get("Authorization")
			if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") {
				http.Error(w, "Unauthorized", http.StatusUnauthorized)
				return
			}

			// Extract token
			tokenString := strings.TrimPrefix(authHeader, "Bearer ")

			// In a real implementation, we would validate the JWT token here
			// For now, we'll just log that we would validate it
			g.logger.Info("JWT validation would happen here")

			// Example of what JWT validation might look like:
			/*
			token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
				// Validate signing method
				if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
					return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
				}
				return []byte(g.config.Security.JWTSecret), nil
			})

			if err != nil || !token.Valid {
				g.logger.WithError(err).Warn("Invalid JWT token")
				http.Error(w, "Unauthorized", http.StatusUnauthorized)
				return
			}

			// Check claims (scopes, expiration, etc.)
			if claims, ok := token.Claims.(jwt.MapClaims); ok {
				// Add claims to request context for use in handlers
				ctx := context.WithValue(r.Context(), "user", claims)
				r = r.WithContext(ctx)
			}
			*/
		}

		next.ServeHTTP(w, r)
	})
}

// requestValidationMiddleware validates incoming requests
func (g *Gateway) requestValidationMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if g.config.Security.EnableRequestValidation {
			// Validate content type for POST/PUT/PATCH requests
			if r.Method == http.MethodPost || r.Method == http.MethodPut || r.Method == http.MethodPatch {
				contentType := r.Header.Get("Content-Type")
				if contentType == "" {
					http.Error(w, "Content-Type header is required", http.StatusBadRequest)
					return
				}

				// In a real implementation, we would validate the request body schema
				// based on the endpoint and content type
			}
		}

		next.ServeHTTP(w, r)
	})
}

// responseSanitizationMiddleware sanitizes responses
func (g *Gateway) responseSanitizationMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if g.config.Security.EnableResponseSanitization {
			// Create a response writer wrapper that can sanitize responses
			// In a real implementation, we would intercept the response and
			// sanitize it before sending it to the client
			
			// For demonstration, we'll just add a header indicating sanitization would occur
			w.Header().Set("X-Content-Sanitized", "true")
		}

		next.ServeHTTP(w, r)
	})
}

// requestTimeoutMiddleware applies request timeouts
func (g *Gateway) requestTimeoutMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if g.config.Security.EnableRequestTimeout {
			// Parse timeout duration
			timeout, err := time.ParseDuration(g.config.Security.RequestTimeoutDuration)
			if err != nil {
				g.logger.WithError(err).Error("Invalid request timeout duration")
				timeout = 30 * time.Second // Default timeout
			}

			// Create a context with timeout
			ctx, cancel := context.WithTimeout(r.Context(), timeout)
			defer cancel()

			// Create a channel to catch when the request is done
			done := make(chan struct{})
			defer close(done)

			// Create a response writer that can be closed
			// This is a simplified version - in real code you'd implement
			// a proper response writer wrapper
			go func() {
				next.ServeHTTP(w, r.WithContext(ctx))
				done <- struct{}{}
			}()

			select {
			case <-done:
				// Request completed normally
				return
			case <-ctx.Done():
				// Request timed out
				if ctx.Err() == context.DeadlineExceeded {
					g.logger.Warn("Request timed out")
					http.Error(w, "Request timed out", http.StatusGatewayTimeout)
				}
				return
			}
		}

		next.ServeHTTP(w, r)
	})
}

// panicRecoveryMiddleware recovers from panics
func (g *Gateway) panicRecoveryMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer func() {
			if err := recover(); err != nil {
				// Log the stack trace
				stack := make([]byte, 8192)
				stack = stack[:runtime.Stack(stack, false)]
				
				g.logger.WithFields(logrus.Fields{
					"error": err,
					"stack": string(stack),
					"path":  r.URL.Path,
				}).Error("Panic recovered")

				// Return a 500 Internal Server Error
				http.Error(w, "Internal Server Error", http.StatusInternalServerError)
			}
		}()

		next.ServeHTTP(w, r)
	})
}

// Import missing packages
import (
	"strings"
	"runtime"
)