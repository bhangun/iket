package main

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/http/httputil"
	"net/url"
	"os"
	"os/signal"
	"plugin"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/gorilla/mux"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"gopkg.in/yaml.v3"
	"golang.org/x/time/rate"
)

// Config represents the gateway configuration
type Config struct {
	Server struct {
		Port             int           `yaml:"port"`
		ReadTimeout      time.Duration `yaml:"readTimeout"`
		WriteTimeout     time.Duration `yaml:"writeTimeout"`
		IdleTimeout      time.Duration `yaml:"idleTimeout"`
		PluginsDir       string        `yaml:"pluginsDir"`
		EnableLogging    bool          `yaml:"enableLogging"`
		TLSCertFile      string        `yaml:"tlsCertFile"`
		TLSKeyFile       string        `yaml:"tlsKeyFile"`
		ClientCACertFile string        `yaml:"clientCACertFile"` // For mTLS
		MetricsPort      int           `yaml:"metricsPort"`
	} `yaml:"server"`

	Security struct {
		EnableMTLS             bool          `yaml:"enableMTLS"`
		EnableCSRF             bool          `yaml:"enableCSRF"`
		CSRFTokenExpiry        time.Duration `yaml:"csrfTokenExpiry"`
		RateLimitRequests      int           `yaml:"rateLimitRequests"`
		RateLimitInterval      time.Duration `yaml:"rateLimitInterval"`
		EnableXSS              bool          `yaml:"enableXSS"`
		EnableHSTS             bool          `yaml:"enableHSTS"`
		HSTSMaxAge             int           `yaml:"hstsMaxAge"`
		EnableSecureCookies    bool          `yaml:"enableSecureCookies"`
		JWTSecret              string        `yaml:"jwtSecret"`
		JWTIssuer              string        `yaml:"jwtIssuer"`
		EnableIPWhitelisting   bool          `yaml:"enableIPWhitelisting"`
		WhitelistedIPs         []string      `yaml:"whitelistedIPs"`
		EnableRequestValidation bool         `yaml:"enableRequestValidation"`
		MaxRequestBodySize     int64         `yaml:"maxRequestBodySize"`
	} `yaml:"security"`

	Routes []struct {
		Path           string            `yaml:"path"`
		Destination    string            `yaml:"destination"`
		Methods        []string          `yaml:"methods"`
		RequireAuth    bool              `yaml:"requireAuth"`
		RateLimit      *int              `yaml:"rateLimit"`
		Timeout        *time.Duration    `yaml:"timeout"`
		Headers        map[string]string `yaml:"headers"`
		StripPath      bool              `yaml:"stripPath"`
		ValidateSchema string            `yaml:"validateSchema"`
	} `yaml:"routes"`

	Plugins []struct {
		Name    string                 `yaml:"name"`
		Path    string                 `yaml:"path"`
		Enabled bool                   `yaml:"enabled"`
		Config  map[string]interface{} `yaml:"config"`
	} `yaml:"plugins"`
}

// GatewayPlugin interface that all plugins must implement
type GatewayPlugin interface {
	Name() string
	Initialize(config map[string]interface{}) error
	Middleware() func(http.Handler) http.Handler
	Shutdown() error
}

// Gateway is the main API gateway struct
type Gateway struct {
	config      *Config
	router      *mux.Router
	plugins     []GatewayPlugin
	pluginsMu   sync.RWMutex
	middlewares []func(http.Handler) http.Handler
	rateLimiter *RateLimiter
	metrics     *Metrics
	logger      *Logger
}

// Logger provides structured logging for the gateway
type Logger struct {
	enableLogging bool
}

// NewLogger creates a new logger instance
func NewLogger(enableLogging bool) *Logger {
	return &Logger{
		enableLogging: enableLogging,
	}
}

// Info logs informational messages
func (l *Logger) Info(format string, v ...interface{}) {
	if l.enableLogging {
		log.Printf("[INFO] "+format, v...)
	}
}

// Error logs error messages
func (l *Logger) Error(format string, v ...interface{}) {
	if l.enableLogging {
		log.Printf("[ERROR] "+format, v...)
	}
}

// Warn logs warning messages
func (l *Logger) Warn(format string, v ...interface{}) {
	if l.enableLogging {
		log.Printf("[WARN] "+format, v...)
	}
}

// Metrics collects and exposes gateway metrics
type Metrics struct {
	requestCount    *prometheus.CounterVec
	requestDuration *prometheus.HistogramVec
	responseSize    *prometheus.HistogramVec
	activeRequests  *prometheus.GaugeVec
}

// NewMetrics creates a new metrics instance
func NewMetrics() *Metrics {
	m := &Metrics{
		requestCount: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Name: "gateway_requests_total",
				Help: "Total number of requests processed by the gateway",
			},
			[]string{"method", "path", "status"},
		),
		requestDuration: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name: "gateway_request_duration_seconds",
				Help: "Duration of requests processed by the gateway",
			},
			[]string{"method", "path"},
		),
		responseSize: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name: "gateway_response_size_bytes",
				Help: "Size of responses returned by the gateway",
			},
			[]string{"method", "path"},
		),
		activeRequests: prometheus.NewGaugeVec(
			prometheus.GaugeOpts{
				Name: "gateway_active_requests",
				Help: "Number of active requests being processed by the gateway",
			},
			[]string{"method"},
		),
	}

	// Register all metrics
	prometheus.MustRegister(m.requestCount)
	prometheus.MustRegister(m.requestDuration)
	prometheus.MustRegister(m.responseSize)
	prometheus.MustRegister(m.activeRequests)

	return m
}

// RateLimiter manages rate limiting for the gateway
type RateLimiter struct {
	limiters   map[string]*rate.Limiter
	mu         sync.RWMutex
	perRouteLimit map[string]*rate.Limiter
	globalRequests int
	globalInterval time.Duration
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter(requests int, interval time.Duration) *RateLimiter {
	return &RateLimiter{
		limiters:       make(map[string]*rate.Limiter),
		perRouteLimit:  make(map[string]*rate.Limiter),
		globalRequests: requests,
		globalInterval: interval,
	}
}

// GetLimiter returns a rate limiter for a specific IP address
func (rl *RateLimiter) GetLimiter(ip string) *rate.Limiter {
	rl.mu.RLock()
	limiter, exists := rl.limiters[ip]
	rl.mu.RUnlock()

	if !exists {
		limiter = rate.NewLimiter(rate.Every(rl.globalInterval/time.Duration(rl.globalRequests)), rl.globalRequests)
		rl.mu.Lock()
		rl.limiters[ip] = limiter
		rl.mu.Unlock()
	}

	return limiter
}

// RegisterRouteLimit sets a specific rate limit for a route
func (rl *RateLimiter) RegisterRouteLimit(route string, limit int) {
	rl.mu.Lock()
	defer rl.mu.Unlock()
	rl.perRouteLimit[route] = rate.NewLimiter(rate.Every(rl.globalInterval/time.Duration(limit)), limit)
}

// GetRouteLimiter returns a rate limiter for a specific route and IP
func (rl *RateLimiter) GetRouteLimiter(route string, ip string) *rate.Limiter {
	routeKey := route + ":" + ip
	
	rl.mu.RLock()
	limiter, exists := rl.limiters[routeKey]
	routeLimiter, routeExists := rl.perRouteLimit[route]
	rl.mu.RUnlock()

	if !exists {
		if routeExists {
			// Create a new limiter based on the route-specific configuration
			limit := routeLimiter.Limit()
			burst := routeLimiter.Burst()
			limiter = rate.NewLimiter(limit, burst)
		} else {
			// Fall back to the global rate limit
			limiter = rate.NewLimiter(rate.Every(rl.globalInterval/time.Duration(rl.globalRequests)), rl.globalRequests)
		}
		
		rl.mu.Lock()
		rl.limiters[routeKey] = limiter
		rl.mu.Unlock()
	}

	return limiter
}

// IPWhitelist manages whitelisted IP addresses
type IPWhitelist struct {
	enabled     bool
	whitelistedIPs []string
}

// NewIPWhitelist creates a new IP whitelist
func NewIPWhitelist(enabled bool, ips []string) *IPWhitelist {
	return &IPWhitelist{
		enabled:     enabled,
		whitelistedIPs: ips,
	}
}

// IsAllowed checks if an IP is allowed
func (ip *IPWhitelist) IsAllowed(addr string) bool {
	if !ip.enabled {
		return true
	}

	for _, whitelisted := range ip.whitelistedIPs {
		if whitelisted == addr || whitelisted == "*" {
			return true
		}
	}

	return false
}

// NewGateway creates a new API gateway instance
func NewGateway(configPath string) (*Gateway, error) {
	config, err := loadConfig(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load config: %w", err)
	}

	logger := NewLogger(config.Server.EnableLogging)
	metrics := NewMetrics()
	rateLimiter := NewRateLimiter(
		config.Security.RateLimitRequests, 
		config.Security.RateLimitInterval * time.Second,
	)

	// Set up custom rate limits for routes if configured
	for _, route := range config.Routes {
		if route.RateLimit != nil {
			rateLimiter.RegisterRouteLimit(route.Path, *route.RateLimit)
		}
	}

	gateway := &Gateway{
		config:      config,
		router:      mux.NewRouter(),
		plugins:     make([]GatewayPlugin, 0),
		middlewares: make([]func(http.Handler) http.Handler, 0),
		rateLimiter: rateLimiter,
		metrics:     metrics,
		logger:      logger,
	}

	// Set up the router
	gateway.setupRoutes()

	// Load plugins
	if err := gateway.loadPlugins(); err != nil {
		return nil, fmt.Errorf("failed to load plugins: %w", err)
	}

	return gateway, nil
}

// loadConfig loads the gateway configuration from a YAML file
func loadConfig(path string) (*Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var config Config
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, err
	}

	return &config, nil
}

// setupRoutes configures the routes from the config
func (g *Gateway) setupRoutes() {
	// Add health check endpoint
	g.router.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(`{"status":"UP"}`))
	}).Methods(http.MethodGet)

	// Configure routes from the config
	for _, route := range g.config.Routes {
		handler := g.proxyHandler(route)
		
		// Apply route-specific middleware
		if route.RequireAuth {
			handler = g.authMiddleware(handler)
		}
		
		// Apply route-specific timeout if configured
		if route.Timeout != nil {
			handler = g.timeoutMiddleware(*route.Timeout)(handler)
		}
		
		// Apply schema validation if configured
		if route.ValidateSchema != "" {
			handler = g.validateRequestMiddleware(route.ValidateSchema)(handler)
		}

		g.router.HandleFunc(route.Path, handler).
			Methods(route.Methods...)
	}

	// Add catch-all route for 404s
	g.router.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusNotFound)
		w.Write([]byte(`{"error":"Not Found","message":"The requested resource does not exist"}`))
	})
}

// proxyHandler returns a handler function that proxies requests to the destination
func (g *Gateway) proxyHandler(route struct {
	Path           string            `yaml:"path"`
	Destination    string            `yaml:"destination"`
	Methods        []string          `yaml:"methods"`
	RequireAuth    bool              `yaml:"requireAuth"`
	RateLimit      *int              `yaml:"rateLimit"`
	Timeout        *time.Duration    `yaml:"timeout"`
	Headers        map[string]string `yaml:"headers"`
	StripPath      bool              `yaml:"stripPath"`
	ValidateSchema string            `yaml:"validateSchema"`
}) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		
		// Parse the destination URL
		target, err := url.Parse(route.Destination)
		if err != nil {
			g.logger.Error("Failed to parse destination URL: %v", err)
			w.WriteHeader(http.StatusInternalServerError)
			w.Write([]byte(`{"error":"Internal Server Error"}`))
			return
		}

		// Create the reverse proxy
		proxy := httputil.NewSingleHostReverseProxy(target)
		
		// Customize the director function to modify the request
		originalDirector := proxy.Director
		proxy.Director = func(req *http.Request) {
			originalDirector(req)
			
			// Strip the path prefix if configured
			if route.StripPath {
				req.URL.Path = strings.TrimPrefix(req.URL.Path, route.Path)
				if req.URL.Path == "" {
					req.URL.Path = "/"
				}
			}
			
			// Add custom headers
			for key, value := range route.Headers {
				req.Header.Set(key, value)
			}
			
			// Add X-Forwarded headers
			req.Header.Set("X-Forwarded-Host", req.Host)
			req.Header.Set("X-Forwarded-For", getClientIP(req))
			
			// Add X-Request-ID for tracking
			if reqID := r.Header.Get("X-Request-ID"); reqID == "" {
				req.Header.Set("X-Request-ID", generateRequestID())
			} else {
				req.Header.Set("X-Request-ID", reqID)
			}
		}
		
		// Customize the error handler
		proxy.ErrorHandler = func(w http.ResponseWriter, r *http.Request, err error) {
			g.logger.Error("Proxy error: %v", err)
			w.WriteHeader(http.StatusBadGateway)
			w.Write([]byte(`{"error":"Bad Gateway","message":"Unable to reach the upstream service"}`))
		}
		
		// Customize the response writer to log and collect metrics
		lrw := newLoggingResponseWriter(w)
		
		// Execute the proxy
		proxy.ServeHTTP(lrw, r)
		
		// Record metrics
		duration := time.Since(start).Seconds()
		g.metrics.requestDuration.WithLabelValues(r.Method, route.Path).Observe(duration)
		g.metrics.requestCount.WithLabelValues(r.Method, route.Path, fmt.Sprintf("%d", lrw.statusCode)).Inc()
		g.metrics.responseSize.WithLabelValues(r.Method, route.Path).Observe(float64(lrw.bytesWritten))
		
		// Log the request
		g.logger.Info("%s %s %d %s %dB", r.Method, r.URL.Path, lrw.statusCode, time.Since(start), lrw.bytesWritten)
	}
}

// generateRequestID generates a unique request ID
func generateRequestID() string {
	return fmt.Sprintf("%d", time.Now().UnixNano())
}

// getClientIP gets the client IP address from the request
func getClientIP(r *http.Request) string {
	// Check for X-Forwarded-For header
	forwardedFor := r.Header.Get("X-Forwarded-For")
	if forwardedFor != "" {
		// X-Forwarded-For can contain multiple IPs, take the first one
		ips := strings.Split(forwardedFor, ",")
		return strings.TrimSpace(ips[0])
	}
	
	// Check for X-Real-IP header
	realIP := r.Header.Get("X-Real-IP")
	if realIP != "" {
		return realIP
	}
	
	// Fall back to RemoteAddr
	return strings.Split(r.RemoteAddr, ":")[0]
}

// loadPlugins loads and initializes all enabled plugins
func (g *Gateway) loadPlugins() error {
	for _, pluginConfig := range g.config.Plugins {
		if !pluginConfig.Enabled {
			g.logger.Info("Plugin %s is disabled, skipping", pluginConfig.Name)
			continue
		}

		g.logger.Info("Loading plugin: %s from %s", pluginConfig.Name, pluginConfig.Path)

		// Load the plugin
		plug, err := plugin.Open(pluginConfig.Path)
		if err != nil {
			return fmt.Errorf("failed to open plugin %s: %w", pluginConfig.Name, err)
		}

		// Look up the plugin's constructor
		symPlugin, err := plug.Lookup("Plugin")
		if err != nil {
			return fmt.Errorf("failed to lookup 'Plugin' symbol in %s: %w", pluginConfig.Name, err)
		}

		// Cast to the GatewayPlugin interface
		gatewayPlugin, ok := symPlugin.(GatewayPlugin)
		if !ok {
			return fmt.Errorf("plugin %s does not implement GatewayPlugin interface", pluginConfig.Name)
		}

		// Initialize the plugin with its configuration
		if err := gatewayPlugin.Initialize(pluginConfig.Config); err != nil {
			return fmt.Errorf("failed to initialize plugin %s: %w", pluginConfig.Name, err)
		}

		// Add the plugin to the list
		g.pluginsMu.Lock()
		g.plugins = append(g.plugins, gatewayPlugin)

		// Register the plugin's middleware
		middleware := gatewayPlugin.Middleware()
		if middleware != nil {
			g.middlewares = append(g.middlewares, middleware)
		}
		g.pluginsMu.Unlock()

		g.logger.Info("Plugin %s loaded successfully", pluginConfig.Name)
	}

	return nil
}

// Serve starts the gateway server
func (g *Gateway) Serve() error {
	// Apply core security middlewares first
	var handler http.Handler = g.router
	
	// Apply security middlewares
	handler = g.rateLimitMiddleware(handler)
	handler = g.ipWhitelistMiddleware(handler)
	handler = g.securityHeadersMiddleware(handler)
	handler = g.csrfMiddleware(handler)
	handler = g.requestSizeMiddleware(handler)
	
	// Apply plugin middlewares in reverse order (last added, first executed)
	for i := len(g.middlewares) - 1; i >= 0; i-- {
		handler = g.middlewares[i](handler)
	}

	// Add logging middleware if enabled
	if g.config.Server.EnableLogging {
		handler = g.loggingMiddleware(handler)
	}

	// Add metrics middleware
	handler = g.metricsMiddleware(handler)

	// Configure the server
	addr := fmt.Sprintf(":%d", g.config.Server.Port)
	server := &http.Server{
		Addr:         addr,
		Handler:      handler,
		ReadTimeout:  g.config.Server.ReadTimeout * time.Second,
		WriteTimeout: g.config.Server.WriteTimeout * time.Second,
		IdleTimeout:  g.config.Server.IdleTimeout * time.Second,
	}

	// Configure TLS if cert and key files are provided
	var tlsConfig *tls.Config
	if g.config.Server.TLSCertFile != "" && g.config.Server.TLSKeyFile != "" {
		tlsConfig = &tls.Config{
			MinVersion: tls.VersionTLS12,
			CipherSuites: []uint16{
				tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
				tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
				tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,
				tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
				tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
				tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
			},
			PreferServerCipherSuites: true,
		}
		
		// Configure mTLS if enabled and client CA cert is provided
		if g.config.Security.EnableMTLS && g.config.Server.ClientCACertFile != "" {
			caCert, err := os.ReadFile(g.config.Server.ClientCACertFile)
			if err != nil {
				return fmt.Errorf("failed to read client CA cert file: %w", err)
			}
			
			caCertPool := x509.NewCertPool()
			if !caCertPool.AppendCertsFromPEM(caCert) {
				return fmt.Errorf("failed to parse client CA cert file")
			}
			
			tlsConfig.ClientCAs = caCertPool
			tlsConfig.ClientAuth = tls.RequireAndVerifyClientCert
		}
		
		server.TLSConfig = tlsConfig
	}

	// Start metrics server on a separate port
	if g.config.Server.MetricsPort > 0 {
		metricsServer := &http.Server{
			Addr:    fmt.Sprintf(":%d", g.config.Server.MetricsPort),
			Handler: promhttp.Handler(),
		}
		
		go func() {
			g.logger.Info("Starting metrics server on :%d", g.config.Server.MetricsPort)
			if err := metricsServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
				g.logger.Error("Failed to start metrics server: %v", err)
			}
		}()
	}

	// Handle graceful shutdown
	done := make(chan os.Signal, 1)
	signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		g.logger.Info("Starting gateway server on %s", addr)
		var err error
		if server.TLSConfig != nil {
			err = server.ListenAndServeTLS(g.config.Server.TLSCertFile, g.config.Server.TLSKeyFile)
		} else {
			err = server.ListenAndServe()
		}
		
		if err != nil && err != http.ErrServerClosed {
			g.logger.Error("Failed to start server: %v", err)
			os.Exit(1)
		}
	}()

	<-done
	g.logger.Info("Server is shutting down...")

	// Shutdown plugins
	g.shutdownPlugins()

	// Create a deadline to wait for
	ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	defer cancel()

	if err := server.Shutdown(ctx); err != nil {
		return fmt.Errorf("server forced to shutdown: %w", err)
	}

	g.logger.Info("Server gracefully stopped")
	return nil
}

// shutdownPlugins gracefully shuts down all plugins
func (g *Gateway) shutdownPlugins() {
	g.pluginsMu.RLock()
	defer g.pluginsMu.RUnlock()

	for _, p := range g.plugins {
		if err := p.Shutdown(); err != nil {
			g.logger.Error("Error shutting down plugin %s: %v", p.Name(), err)
		} else {
			g.logger.Info("Plugin %s shutdown successfully", p.Name())
		}
	}
}

// Security Middlewares

// rateLimitMiddleware implements rate limiting
func (g *Gateway) rateLimitMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Get client IP
		clientIP := getClientIP(r)
		
		// Get route-specific limiter if available
		limiter := g.rateLimiter.GetRouteLimiter(r.URL.Path, clientIP)
		
		// Check if the request is allowed
		if !limiter.Allow() {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusTooManyRequests)
			w.Write([]byte(`{"error":"Too Many Requests","message":"Rate limit exceeded"}`))
			return
		}
		
		next.ServeHTTP(w, r)
	})
}

// ipWhitelistMiddleware implements IP whitelisting
func (g *Gateway) ipWhitelistMiddleware(next http.Handler) http.Handler {
	whitelist := NewIPWhitelist(g.config.Security.EnableIPWhitelisting, g.config.Security.WhitelistedIPs)
	
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		clientIP := getClientIP(r)
		
		if !whitelist.IsAllowed(clientIP) {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusForbidden)
			w.Write([]byte(`{"error":"Forbidden","message":"IP address not allowed"}`))
			return
		}
		
		next.ServeHTTP(w, r)
	})
}

// securityHeadersMiddleware adds security headers to responses
func (g *Gateway) securityHeadersMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Set security headers
		w.Header().Set("X-Content-Type-Options", "nosniff")
		w.Header().Set("X-Frame-Options", "DENY")
		
		// Set XSS Protection header if enabled
		if g.config.Security.EnableXSS {
			w.Header().Set("X-XSS-Protection", "1; mode=block")
		}
		
		// Set HSTS header if enabled
		if g.config.Security.EnableHSTS {
			maxAge := g.config.Security.HSTSMaxAge
			if maxAge <= 0 {
				maxAge = 31536000 // Default to 1 year
			}
			w.Header().Set("Strict-Transport-Security", fmt.Sprintf("max-age=%d; includeSubDomains", maxAge))
		}
		
		next.ServeHTTP(w, r)
	})
}

// csrfMiddleware implements CSRF protection
func (g *Gateway) csrfMiddleware(next http.Handler) http.Handler {
	if !g.config.Security.EnableCSRF {
		return next
	}
	
	// In a real implementation, this would use a proper CSRF token implementation
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Only check CSRF for state-changing methods
		if r.Method == http.MethodPost || r.Method == http.MethodPut || 
		   r.Method == http.MethodDelete || r.Method == http.MethodPatch {
			// Check CSRF token
			token := r.Header.Get("X-CSRF-Token")
			if token == "" {
				w.Header().Set("Content-Type", "application/json")
				w.WriteHeader(http.StatusForbidden)
				w.Write([]byte(`{"error":"Forbidden","message":"CSRF token missing"}`))
				return
			}
			
			// Validate token (simplified for example purposes)
			// In a real implementation, this would validate the token against a stored value
			if len(token) < 32 {
				w.Header().Set("Content-Type", "application/json")
				w.WriteHeader(http.StatusForbidden)
				w.Write([]byte(`{"error":"Forbidden","message":"Invalid CSRF token"}`))
				return
			}
		}
		
		next.ServeHTTP(w, r)
	})
}

// requestSizeMiddleware limits the size of incoming requests
func (g *Gateway) requestSizeMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Skip for GET and HEAD requests
		if r.Method == http.MethodGet || r.Method == http.MethodHead {
			next.ServeHTTP(w, r)
			return
		}
		
		// Check Content-Length header
		if r.ContentLength > g.config.Security.MaxRequestBodySize {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusRequestEntityTooLarge)
			w.Write([]byte(`{"error":"Request Entity Too Large","message":"Request body too large"}`))
			return
		}
		
		// Limit the request body
		r.Body = http.MaxBytesReader(w, r.Body, g.config.Security.MaxRequestBodySize)
		
		next.ServeHTTP(w, r)
	})
}

// authMiddleware implements JWT authentication
func (g *Gateway) authMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Extract the token from